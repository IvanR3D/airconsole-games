<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>STEAM Platformer - Fundacion STEAM RD</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
    <script type="text/javascript" src="https://www.airconsole.com/api/airconsole-1.9.0.js"></script>
    
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        steam: {
                            turquesa: '#0595AE',
                            morado: '#AB3D8B',
                            naranja: '#EB8225',
                            verde: '#73A03F',
                            negro: '#010101',
                            blanco: '#FFFFFF'
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        /* ==========================================================================
           BASE STYLES
           ========================================================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            position: fixed;
            top: 0;
            left: 0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #f8f9fa;
        }

        /* ==========================================================================
           TITLE STYLES
           ========================================================================== */
        .title-steam { color: #0595AE; }
        .title-platformer { color: #73A03F; }

        /* ==========================================================================
           PLAYER AVATAR
           ========================================================================== */
        .player-avatar {
            width: clamp(50px, 8vw, 80px);
            height: clamp(50px, 8vw, 80px);
            border-radius: 16px;
            position: relative;
            box-shadow: 0 6px 0 rgba(0,0,0,0.15), 0 8px 25px rgba(0,0,0,0.1);
        }

        .player-avatar::before,
        .player-avatar::after {
            content: '';
            position: absolute;
            width: 24%;
            height: 24%;
            top: 32%;
            background: radial-gradient(circle at 50% 50%, #222 35%, transparent 36%), white;
            border-radius: 50%;
            animation: idleBlink 4s ease-in-out infinite;
        }
        
        .player-avatar::before { left: 18%; }
        .player-avatar::after { right: 18%; animation-delay: 0.05s; }

        .player-avatar-small {
            width: clamp(35px, 5vw, 50px);
            height: clamp(35px, 5vw, 50px);
            border-radius: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.15);
        }

        /* ==========================================================================
           PLAYER CARD
           ========================================================================== */
        .player-card {
            background: white;
            border-radius: 20px;
            padding: clamp(16px, 3vw, 28px);
            border: 4px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .player-card.ready {
            border-color: #73A03F;
            background: #f0fdf4;
        }

        .player-card.admin {
            border-color: #EB8225;
            background: #fff7ed;
        }

        /* Player card ready/admin animations */
        .player-card.ready .player-avatar::before,
        .player-card.ready .player-avatar::after,
        .player-card.admin .player-avatar::before,
        .player-card.admin .player-avatar::after {
            animation: blinkHappy 0.6s ease-out, idleBlink 4s ease-in-out 0.6s infinite;
        }

        .player-card.ready .player-avatar,
        .player-card.admin .player-avatar {
            animation: happyJump 0.5s ease-out;
        }

        /* ==========================================================================
           COUNTDOWN
           ========================================================================== */
        .countdown-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .countdown-number {
            font-size: clamp(120px, 30vw, 250px);
            font-weight: 900;
            color: white;
            text-shadow: 0 0 60px currentColor;
            animation: countPop 0.6s ease-out;
        }

        /* ==========================================================================
           ANIMATIONS
           ========================================================================== */
        @keyframes idleBlink {
            0%, 42%, 48%, 100% { transform: scaleY(1); }
            45% { transform: scaleY(0.05); }
        }

        @keyframes blinkHappy {
            0% { transform: scaleY(1); }
            20% { transform: scaleY(0.05); }
            40% { transform: scaleY(1); }
            60% { transform: scaleY(0.05); }
            80%, 100% { transform: scaleY(1); }
        }

        @keyframes happyJump {
            0% { transform: scale(1); }
            40% { transform: scale(1.15) translateY(-12px); }
            70% { transform: scale(0.95) translateY(0); }
            100% { transform: scale(1) translateY(0); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        .float { animation: float 3s ease-in-out infinite; }

        @keyframes countPop {
            0% { transform: scale(2.5); opacity: 0; }
            60% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes fall {
            to { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        
        .confetti {
            position: absolute;
            animation: fall 3s ease-out forwards;
        }

        @keyframes pulse { 50% { opacity: 0.6; } }
        .pulse { animation: pulse 2s ease infinite; }

        @keyframes winner {
            0% { transform: scale(0) rotate(-10deg); }
            70% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        .winner-anim { animation: winner 0.6s ease-out; }
    </style>
</head>
<body>
    <!-- START SCREEN -->
    <div id="startScreen" class="w-screen h-screen flex flex-col items-center justify-center p-6 text-center bg-gray-50">
        <div class="mb-6">
            <h1 class="text-4xl sm:text-5xl lg:text-6xl font-black mb-2 flex items-center justify-center gap-3">
                <iconify-icon icon="mdi:gamepad-variant" class="text-steam-turquesa"></iconify-icon>
                <span class="title-steam">STEAM</span> <span class="title-platformer">PLATFORMER</span>
            </h1>
            <p class="text-gray-500 text-lg flex items-center justify-center gap-3">
                <iconify-icon icon="mdi:run-fast"></iconify-icon>
                Corre
                <iconify-icon icon="mdi:arrow-up-bold-box"></iconify-icon>
                Salta
                <iconify-icon icon="mdi:cash-multiple"></iconify-icon>
                Colecta
            </p>
        </div>
        
        <div class="grid grid-cols-2 gap-4 sm:gap-6 mb-8 w-full max-w-xl lg:max-w-3xl">
            <div class="player-card" id="playerSlot1">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 1
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
            <div class="player-card" id="playerSlot2">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 2
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
            <div class="player-card" id="playerSlot3">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 3
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
            <div class="player-card" id="playerSlot4">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 4
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
        </div>
        
        <div class="bg-steam-naranja/10 border-2 border-steam-naranja rounded-2xl py-4 px-8 hidden flex items-center gap-3" id="adminHint">
            <iconify-icon icon="mdi:cellphone" class="text-steam-naranja text-2xl"></iconify-icon>
            <p class="text-steam-naranja font-bold">El Jugador 1 inicia desde su telefono</p>
        </div>
        
        <!-- Level Selection -->
        <div class="mt-6 hidden" id="levelSelector">
            <h3 class="text-lg font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                <iconify-icon icon="mdi:map-marker-path"></iconify-icon>
                Selecciona Nivel
            </h3>
            <div class="flex gap-2 justify-center flex-wrap max-w-md mx-auto">
                <button class="level-btn bg-steam-verde text-white font-bold py-2 px-4 rounded-xl border-2 border-steam-verde" data-level="1">1</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="2">2</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="3">3</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="4">4</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="5">5</button>
            </div>
            <p class="text-sm text-gray-500 mt-2 text-center" id="levelName">Inicio Facil</p>
        </div>
    </div>

    <!-- GAME CONTAINER -->
    <div id="gameContainer" class="hidden w-screen h-screen fixed inset-0 overflow-hidden"></div>

    <!-- COUNTDOWN -->
    <div id="countdownOverlay" class="countdown-overlay hidden">
        <div class="countdown-number" id="countdownNumber">3</div>
    </div>

    <!-- RESULTS SCREEN -->
    <div id="resultsScreen" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4 bg-gray-50">
        <div class="bg-white rounded-3xl p-6 sm:p-10 text-center w-full max-w-2xl shadow-2xl max-h-[95vh] overflow-y-auto">
            <h2 class="text-3xl sm:text-4xl font-black text-steam-turquesa mb-6 flex items-center justify-center gap-3">
                <iconify-icon icon="mdi:flag-checkered"></iconify-icon>
                Fin de Carrera!
            </h2>
            <div class="winner-anim mb-8" id="winnerSection"></div>
            <table class="w-full mb-8 text-left">
                <thead>
                    <tr class="border-b-4 border-gray-100">
                        <th class="py-3 px-2 text-steam-turquesa font-bold">#</th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold">
                            <span class="flex items-center gap-1">
                                <iconify-icon icon="mdi:account"></iconify-icon>
                                Jugador
                            </span>
                        </th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold text-center">
                            <span class="flex items-center justify-center gap-1">
                                <iconify-icon icon="mdi:cash"></iconify-icon>
                                Monedas
                            </span>
                        </th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold text-center">
                            <span class="flex items-center justify-center gap-1">
                                <iconify-icon icon="mdi:timer"></iconify-icon>
                                Tiempo
                            </span>
                        </th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold text-right">
                            <span class="flex items-center justify-end gap-1">
                                <iconify-icon icon="mdi:star"></iconify-icon>
                                Puntos
                            </span>
                        </th>
                    </tr>
                </thead>
                <tbody id="resultsBody"></tbody>
            </table>
            <div class="flex gap-4" id="resultsActions">
                <button class="btn btn-turquesa py-4 px-8 text-base hidden pulse flex items-center gap-2" id="nextLevelBtn">
                    <iconify-icon icon="mdi:arrow-right-bold"></iconify-icon>
                    SIGUIENTE NIVEL
                </button>
                <button class="btn btn-morado py-4 px-8 text-base hidden pulse flex items-center gap-2" id="levelSelectBtn">
                    <iconify-icon icon="mdi:map-marker-path"></iconify-icon>
                    SELECCIONAR NIVEL
                </button>
            </div>
            <div class="bg-steam-naranja/10 border-2 border-steam-naranja rounded-xl py-4 px-6 pulse flex items-center justify-center gap-2" id="waitingAdmin">
                <iconify-icon icon="mdi:cellphone" class="text-steam-naranja text-xl"></iconify-icon>
                <p class="text-steam-naranja font-bold">Esperando al Jugador 1...</p>
            </div>
        </div>
    </div>

    <!-- CONFETTI -->
    <div class="fixed inset-0 pointer-events-none z-[1000] overflow-hidden" id="confettiContainer"></div>

    <script>
    /**
     * STEAM Platformer - Screen Controller
     * 
     * Manages game state, player connections, physics, and game rendering.
     * Broadcasts game events to controllers via AirConsole.
     * 
     * @fileoverview Main game screen module for the STEAM Platformer
     * @version 2.0.0
     */

    // ==========================================================================
    // CONFIGURATION
    // ==========================================================================
    
    const CONFIG = {
        MAX_PLAYERS: 4,
        COLORS: ['#73A03F', '#AB3D8B', '#0595AE', '#EB8225'],
        NAMES: ['Verde', 'Morado', 'Turquesa', 'Naranja'],
        CONFETTI_COLORS: ['#0595AE', '#AB3D8B', '#EB8225', '#73A03F', '#FFD700'],
        CONFETTI_COUNT: 150
    };

    const PHYSICS = {
        GRAVITY: 0.5,
        MAX_FALL_SPEED: 15,
        MOVE_SPEED: 7,
        JUMP_POWER: -70,
        AIR_ACCELERATION: 0.7,
        GROUND_ACCELERATION: 0.85,
        FRICTION: 0.7,
        AIR_RESISTANCE: 0.95,
        JUMP_CUT_MULTIPLIER: 0.5,
        JUMP_CUT_THRESHOLD: -5
    };

    // ==========================================================================
    // LEVEL DATA
    // ==========================================================================
    
    const LEVELS = {
        1: {
            name: "Inicio Facil",
            length: 3000,
            floorSegments: [
                { x: 0, width: 600 },
                { x: 900, width: 500 },
                { x: 1700, width: 600 },
                { x: 2600, width: 400 }
            ],
            platforms: [
                { x: 450, y: 450, width: 200 },
                { x: 900, y: 380, width: 180 },
                { x: 1400, y: 420, width: 200 },
                { x: 1900, y: 400, width: 180 },
                { x: 2400, y: 370, width: 200 }
            ],
            coins: [
                { x: 550, y: 410 }, { x: 1000, y: 340 }, { x: 1500, y: 380 },
                { x: 2000, y: 360 }, { x: 2500, y: 330 }, { x: 2800, y: 550 }
            ],
            obstacles: [
                { x: 750, y: 250, startX: 750 },
                { x: 1800, y: 240, startX: 1800 }
            ]
        },
        2: {
            name: "Saltos Medianos",
            length: 3800,
            floorSegments: [
                { x: 0, width: 500 },
                { x: 850, width: 400 },
                { x: 1550, width: 500 },
                { x: 2400, width: 450 },
                { x: 3200, width: 600 }
            ],
            platforms: [
                { x: 400, y: 450, width: 180 },
                { x: 750, y: 360, width: 160 },
                { x: 1100, y: 420, width: 200 },
                { x: 1500, y: 340, width: 170 },
                { x: 1900, y: 400, width: 190 },
                { x: 2300, y: 320, width: 160 },
                { x: 2700, y: 380, width: 200 },
                { x: 3100, y: 420, width: 180 }
            ],
            coins: [
                { x: 490, y: 410 }, { x: 840, y: 320 }, { x: 1190, y: 380 },
                { x: 1590, y: 300 }, { x: 1990, y: 360 }, { x: 2390, y: 280 },
                { x: 2790, y: 340 }, { x: 3190, y: 380 }, { x: 3600, y: 550 }
            ],
            obstacles: [
                { x: 650, y: 200, startX: 650 },
                { x: 1350, y: 180, startX: 1350 },
                { x: 2150, y: 190, startX: 2150 },
                { x: 2950, y: 185, startX: 2950 }
            ]
        },
        3: {
            name: "Torre Alta",
            length: 4500,
            floorSegments: [
                { x: 0, width: 450 },
                { x: 800, width: 350 },
                { x: 1500, width: 300 },
                { x: 2150, width: 400 },
                { x: 2900, width: 350 },
                { x: 3600, width: 500 },
                { x: 4350, width: 150 }
            ],
            platforms: [
                { x: 350, y: 460, width: 160 },
                { x: 650, y: 400, width: 150 },
                { x: 950, y: 340, width: 140 },
                { x: 1300, y: 390, width: 160 },
                { x: 1650, y: 330, width: 170 },
                { x: 2000, y: 270, width: 150 },
                { x: 2400, y: 410, width: 180 },
                { x: 2750, y: 350, width: 160 },
                { x: 3150, y: 290, width: 170 },
                { x: 3500, y: 370, width: 180 },
                { x: 3900, y: 410, width: 190 },
                { x: 4250, y: 360, width: 170 }
            ],
            coins: [
                { x: 430, y: 420 }, { x: 730, y: 360 }, { x: 1020, y: 300 },
                { x: 1380, y: 350 }, { x: 1730, y: 290 }, { x: 2070, y: 230 },
                { x: 2490, y: 370 }, { x: 2830, y: 310 }, { x: 3240, y: 250 },
                { x: 3590, y: 330 }, { x: 3990, y: 370 }, { x: 4330, y: 320 }
            ],
            obstacles: [
                { x: 550, y: 180, startX: 550 },
                { x: 1150, y: 160, startX: 1150 },
                { x: 1850, y: 140, startX: 1850 },
                { x: 2600, y: 150, startX: 2600 },
                { x: 3350, y: 135, startX: 3350 },
                { x: 4100, y: 160, startX: 4100 }
            ]
        },
        4: {
            name: "Abismo Peligroso",
            length: 5200,
            floorSegments: [
                { x: 0, width: 400 },
                { x: 750, width: 300 },
                { x: 1400, width: 350 },
                { x: 2100, width: 300 },
                { x: 2750, width: 400 },
                { x: 3500, width: 300 },
                { x: 4150, width: 350 },
                { x: 4850, width: 350 }
            ],
            platforms: [
                { x: 300, y: 450, width: 150 },
                { x: 600, y: 380, width: 130 },
                { x: 900, y: 330, width: 140 },
                { x: 1200, y: 380, width: 150 },
                { x: 1550, y: 420, width: 160 },
                { x: 1850, y: 360, width: 140 },
                { x: 2200, y: 300, width: 150 },
                { x: 2550, y: 390, width: 160 },
                { x: 2900, y: 340, width: 150 },
                { x: 3250, y: 380, width: 140 },
                { x: 3650, y: 320, width: 160 },
                { x: 4000, y: 400, width: 150 },
                { x: 4350, y: 350, width: 140 },
                { x: 4700, y: 390, width: 150 }
            ],
            coins: [
                { x: 375, y: 410 }, { x: 665, y: 340 }, { x: 970, y: 290 },
                { x: 1275, y: 340 }, { x: 1625, y: 380 }, { x: 1920, y: 320 },
                { x: 2275, y: 260 }, { x: 2625, y: 350 }, { x: 2975, y: 300 },
                { x: 3325, y: 340 }, { x: 3720, y: 280 }, { x: 4075, y: 360 },
                { x: 4425, y: 310 }, { x: 4775, y: 350 }, { x: 5000, y: 550 }
            ],
            obstacles: [
                { x: 480, y: 180, startX: 480 },
                { x: 1050, y: 165, startX: 1050 },
                { x: 1700, y: 155, startX: 1700 },
                { x: 2400, y: 145, startX: 2400 },
                { x: 3100, y: 160, startX: 3100 },
                { x: 3850, y: 150, startX: 3850 },
                { x: 4550, y: 170, startX: 4550 }
            ]
        },
        5: {
            name: "Maestro Supremo",
            length: 6000,
            floorSegments: [
                { x: 0, width: 350 },
                { x: 750, width: 280 },
                { x: 1450, width: 300 },
                { x: 2150, width: 280 },
                { x: 2850, width: 320 },
                { x: 3600, width: 280 },
                { x: 4300, width: 300 },
                { x: 5000, width: 280 },
                { x: 5700, width: 300 }
            ],
            platforms: [
                { x: 250, y: 460, width: 130 },
                { x: 550, y: 410, width: 120 },
                { x: 850, y: 350, width: 130 },
                { x: 1150, y: 400, width: 120 },
                { x: 1450, y: 340, width: 130 },
                { x: 1750, y: 280, width: 120 },
                { x: 2050, y: 420, width: 140 },
                { x: 2400, y: 360, width: 130 },
                { x: 2700, y: 300, width: 120 },
                { x: 3050, y: 240, width: 130 },
                { x: 3400, y: 390, width: 140 },
                { x: 3750, y: 330, width: 130 },
                { x: 4100, y: 380, width: 120 },
                { x: 4450, y: 320, width: 130 },
                { x: 4800, y: 270, width: 120 },
                { x: 5150, y: 410, width: 140 },
                { x: 5500, y: 350, width: 130 }
            ],
            coins: [
                { x: 315, y: 420 }, { x: 615, y: 370 }, { x: 920, y: 310 },
                { x: 1220, y: 360 }, { x: 1520, y: 300 }, { x: 1815, y: 240 },
                { x: 2140, y: 380 }, { x: 2485, y: 320 }, { x: 2770, y: 260 },
                { x: 3135, y: 200 }, { x: 3485, y: 350 }, { x: 3835, y: 290 },
                { x: 4185, y: 340 }, { x: 4535, y: 280 }, { x: 4870, y: 230 },
                { x: 5235, y: 370 }, { x: 5585, y: 310 }, { x: 5850, y: 550 }
            ],
            obstacles: [
                { x: 450, y: 170, startX: 450 },
                { x: 1000, y: 155, startX: 1000 },
                { x: 1600, y: 140, startX: 1600 },
                { x: 2250, y: 130, startX: 2250 },
                { x: 2900, y: 145, startX: 2900 },
                { x: 3500, y: 135, startX: 3500 },
                { x: 4200, y: 150, startX: 4200 },
                { x: 4950, y: 140, startX: 4950 },
                { x: 5600, y: 160, startX: 5600 }
            ]
        }
    };

    // ==========================================================================
    // DOM UTILITIES
    // ==========================================================================
    
    const DOM = {
        get: (id) => document.getElementById(id),
        
        elements: {},
        
        init() {
            this.elements = {
                startScreen: this.get('startScreen'),
                gameContainer: this.get('gameContainer'),
                countdownOverlay: this.get('countdownOverlay'),
                countdownNumber: this.get('countdownNumber'),
                resultsScreen: this.get('resultsScreen'),
                winnerSection: this.get('winnerSection'),
                resultsBody: this.get('resultsBody'),
                adminHint: this.get('adminHint'),
                levelSelector: this.get('levelSelector'),
                levelName: this.get('levelName'),
                nextLevelBtn: this.get('nextLevelBtn'),
                levelSelectBtn: this.get('levelSelectBtn'),
                waitingAdmin: this.get('waitingAdmin'),
                confettiContainer: this.get('confettiContainer')
            };
        }
    };

    // ==========================================================================
    // AUDIO MANAGER
    // ==========================================================================
    
    const AudioManager = {
        context: null,
        
        init() {
            if (!this.context) {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
            }
        },
        
        play(type) {
            this.init();
            const ctx = this.context;
            const t = ctx.currentTime;
            
            const sounds = {
                jump: () => this._playTone(400, 800, 0.1, 0.1),
                coin: () => this._playArpeggio([1000, 1250, 1500], 0.08, 0.05),
                hit: () => this._playSawtooth(200, 80, 0.15, 0.12),
                win: () => this._playArpeggio([523, 659, 784, 1047], 0.1, 0.12),
                count: () => this._playTone(500, 500, 0.12, 0.1),
                go: () => this._playArpeggio([600, 900, 1200], 0.12, 0.04)
            };
            
            if (sounds[type]) sounds[type]();
        },
        
        _playTone(startFreq, endFreq, duration, gain) {
            const ctx = this.context;
            const t = ctx.currentTime;
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            
            o.connect(g);
            g.connect(ctx.destination);
            o.frequency.setValueAtTime(startFreq, t);
            o.frequency.exponentialRampToValueAtTime(endFreq, t + duration);
            g.gain.setValueAtTime(gain, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + duration);
            o.start(t);
            o.stop(t + duration);
        },
        
        _playArpeggio(frequencies, gain, delay) {
            const ctx = this.context;
            const t = ctx.currentTime;
            
            frequencies.forEach((f, i) => {
                const osc = ctx.createOscillator();
                const gainNode = ctx.createGain();
                osc.connect(gainNode);
                gainNode.connect(ctx.destination);
                osc.frequency.value = f;
                gainNode.gain.setValueAtTime(gain, t + i * delay);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + i * delay + 0.15);
                osc.start(t + i * delay);
                osc.stop(t + i * delay + 0.15);
            });
        },
        
        _playSawtooth(startFreq, endFreq, duration, gain) {
            const ctx = this.context;
            const t = ctx.currentTime;
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            
            o.type = 'sawtooth';
            o.connect(g);
            g.connect(ctx.destination);
            o.frequency.setValueAtTime(startFreq, t);
            o.frequency.exponentialRampToValueAtTime(endFreq, t + duration);
            g.gain.setValueAtTime(gain, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + duration);
            o.start(t);
            o.stop(t + duration);
        }
    };

    // ==========================================================================
    // EFFECTS MANAGER
    // ==========================================================================
    
    const EffectsManager = {
        spawnConfetti() {
            const container = DOM.elements.confettiContainer;
            container.innerHTML = '';
            
            for (let i = 0; i < CONFIG.CONFETTI_COUNT; i++) {
                const el = document.createElement('div');
                el.className = 'confetti';
                const color = CONFIG.CONFETTI_COLORS[Math.floor(Math.random() * CONFIG.CONFETTI_COLORS.length)];
                el.style.cssText = `
                    left: ${Math.random() * 100}%;
                    top: -20px;
                    width: ${8 + Math.random() * 8}px;
                    height: ${8 + Math.random() * 8}px;
                    background: ${color};
                    border-radius: ${Math.random() > 0.5 ? '50%' : '2px'};
                    animation-delay: ${Math.random() * 2}s;
                    animation-duration: ${2 + Math.random() * 2}s;
                `;
                container.appendChild(el);
            }
            
            setTimeout(() => container.innerHTML = '', 5000);
        }
    };

    // ==========================================================================
    // UI MANAGER
    // ==========================================================================
    
    const UIManager = {
        async countdown() {
            const overlay = DOM.elements.countdownOverlay;
            const num = DOM.elements.countdownNumber;
            overlay.classList.remove('hidden');
            
            const steps = [
                ['3', '#EB8225'],
                ['2', '#AB3D8B'],
                ['1', '#0595AE'],
                ['GO!', '#73A03F']
            ];
            
            for (const [val, color] of steps) {
                num.textContent = val;
                num.style.color = color;
                num.style.animation = 'none';
                num.offsetHeight; // Force reflow
                num.style.animation = 'countPop 0.6s ease-out';
                AudioManager.play(val === 'GO!' ? 'go' : 'count');
                await new Promise(r => setTimeout(r, 750));
            }
            
            overlay.classList.add('hidden');
        },
        
        updatePlayerSlots(players, admin) {
            const count = Object.keys(players).length;
            
            for (let i = 1; i <= CONFIG.MAX_PLAYERS; i++) {
                const slot = DOM.get(`playerSlot${i}`);
                const player = players[i];
                
                slot.className = 'player-card';
                
                if (player) {
                    slot.classList.add(player.isAdmin ? 'admin' : 'ready');
                    slot.innerHTML = this._renderPlayerSlot(player);
                } else {
                    slot.innerHTML = this._renderEmptySlot(i);
                }
            }
            
            DOM.elements.adminHint.classList.toggle('hidden', count === 0);
            DOM.elements.levelSelector.classList.toggle('hidden', count === 0);
        },
        
        _renderPlayerSlot(player) {
            return `
                <div class="text-lg sm:text-xl font-bold flex items-center justify-center gap-2" style="color:${player.color}">
                    ${player.isAdmin ? '<iconify-icon icon="mdi:crown" class="text-steam-naranja text-2xl"></iconify-icon>' : '<iconify-icon icon="mdi:account-check" class="text-xl"></iconify-icon>'}
                    ${player.name}
                </div>
                <div class="flex justify-center my-3 float">
                    <div class="player-avatar" style="background:${player.color}"></div>
                </div>
                <div class="text-sm font-bold flex items-center justify-center gap-1 ${player.disconnected ? 'text-steam-morado' : 'text-steam-verde'}">
                    ${player.disconnected 
                        ? '<iconify-icon icon="mdi:wifi-off"></iconify-icon> Desconectado' 
                        : '<iconify-icon icon="mdi:check-circle"></iconify-icon> Listo!'}
                </div>
            `;
        },
        
        _renderEmptySlot(slotNum) {
            return `
                <div class="text-lg sm:text-xl font-bold text-gray-400 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador ${slotNum}
                </div>
                <div class="flex justify-center my-3 float">
                    <div class="player-avatar bg-gray-200"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            `;
        },
        
        showResults(results, levelCompleted, hasNextLevel) {
            const winnerDiv = DOM.elements.winnerSection;
            
            if (results.length) {
                const winner = results[0];
                winnerDiv.innerHTML = `
                    <iconify-icon icon="mdi:trophy" class="text-6xl text-steam-naranja mb-4"></iconify-icon>
                    <div class="player-avatar mx-auto mb-4" style="background:${winner.color};width:100px;height:100px;border-radius:20px;box-shadow:0 0 30px ${winner.color}50"></div>
                    <div class="text-2xl font-black" style="color:${winner.color}">${winner.name}</div>
                    <div class="text-xl text-steam-verde font-bold mt-2 flex items-center justify-center gap-2">
                        <iconify-icon icon="mdi:star"></iconify-icon>
                        ${winner.score} pts
                    </div>
                `;
                AudioManager.play('win');
                EffectsManager.spawnConfetti();
            }
            
            this._renderResultsTable(results);
            this._updateResultButtons(levelCompleted, hasNextLevel);
            
            DOM.elements.resultsScreen.style.display = 'flex';
        },
        
        _renderResultsTable(results) {
            const tbody = DOM.elements.resultsBody;
            tbody.innerHTML = '';
            
            const medals = ['mdi:medal-outline', 'mdi:medal-outline', 'mdi:medal-outline'];
            const medalColors = ['#FFD700', '#C0C0C0', '#CD7F32'];
            
            results.forEach((r, i) => {
                const row = document.createElement('tr');
                row.className = i === 0 ? 'bg-amber-50' : i % 2 ? 'bg-gray-50' : '';
                row.innerHTML = `
                    <td class="py-3 px-2 text-xl">
                        ${i < 3 
                            ? `<iconify-icon icon="${medals[i]}" style="color:${medalColors[i]}" class="text-2xl"></iconify-icon>` 
                            : `#${i+1}`}
                    </td>
                    <td class="py-3 px-2">
                        <div class="flex items-center gap-2">
                            <div class="w-6 h-6 rounded-md relative" style="background:${r.color}">
                                <span class="absolute top-1 left-1 w-1.5 h-1.5 bg-white rounded-full"></span>
                                <span class="absolute top-1 right-1 w-1.5 h-1.5 bg-white rounded-full"></span>
                            </div>
                            <span class="font-bold">${r.name}</span>
                        </div>
                    </td>
                    <td class="py-3 px-2 text-center text-steam-naranja font-bold">${r.coins}</td>
                    <td class="py-3 px-2 text-center">${r.time}s</td>
                    <td class="py-3 px-2 text-right font-black text-steam-verde">${r.score}</td>
                `;
                tbody.appendChild(row);
            });
        },
        
        _updateResultButtons(levelCompleted, hasNextLevel) {
            if (levelCompleted && hasNextLevel) {
                DOM.elements.nextLevelBtn.classList.remove('hidden');
            } else {
                DOM.elements.nextLevelBtn.classList.add('hidden');
            }
            
            DOM.elements.levelSelectBtn.classList.remove('hidden');
            DOM.elements.waitingAdmin.classList.add('hidden');
        }
    };

    // ==========================================================================
    // LEVEL MANAGER
    // ==========================================================================
    
    const LevelManager = {
        progress: {
            currentLevel: 1,
            unlockedLevels: [1],
            completedLevels: []
        },
        
        init() {
            this.setupButtons();
        },
        
        setupButtons() {
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const level = parseInt(btn.dataset.level);
                    if (this.progress.unlockedLevels.includes(level)) {
                        this.selectLevel(level);
                    }
                });
            });
        },
        
        selectLevel(level) {
            this.progress.currentLevel = level;
            this.updateButtons();
            DOM.elements.levelName.textContent = LEVELS[level].name;
            GameManager.airconsole.broadcast({ action: 'levelChanged', level, name: LEVELS[level].name });
        },
        
        updateButtons() {
            document.querySelectorAll('.level-btn').forEach(btn => {
                const btnLevel = parseInt(btn.dataset.level);
                const isUnlocked = this.progress.unlockedLevels.includes(btnLevel);
                const isSelected = btnLevel === this.progress.currentLevel;
                const isCompleted = this.progress.completedLevels.includes(btnLevel);
                
                if (isSelected) {
                    btn.className = 'level-btn bg-steam-verde text-white font-bold py-2 px-4 rounded-xl border-2 border-steam-verde';
                    btn.disabled = false;
                } else if (isCompleted) {
                    btn.className = 'level-btn bg-steam-turquesa text-white font-bold py-2 px-4 rounded-xl border-2 border-steam-turquesa';
                    btn.disabled = false;
                } else if (isUnlocked) {
                    btn.className = 'level-btn bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-xl border-2 border-gray-300';
                    btn.disabled = false;
                } else {
                    btn.className = 'level-btn bg-gray-100 text-gray-400 font-bold py-2 px-4 rounded-xl border-2 border-gray-200 opacity-50 cursor-not-allowed';
                    btn.disabled = true;
                }
            });
        },
        
        completeLevel(level) {
            if (!this.progress.completedLevels.includes(level)) {
                this.progress.completedLevels.push(level);
            }
            
            const nextLevel = level + 1;
            if (nextLevel <= 5 && !this.progress.unlockedLevels.includes(nextLevel)) {
                this.progress.unlockedLevels.push(nextLevel);
            }
        },
        
        getLevelData() {
            return LEVELS[this.progress.currentLevel];
        },
        
        hasNextLevel() {
            return this.progress.currentLevel < 5;
        }
    };

    // ==========================================================================
    // GAME CLASS
    // ==========================================================================
    
    class Game {
        constructor(playerNum, color, name) {
            this.num = playerNum;
            this.color = color;
            this.name = name;
            
            // Canvas
            this.canvas = null;
            this.ctx = null;
            
            // Input
            this.keys = { left: false, right: false, jump: false };
            
            // State
            this.finishTime = null;
            this.resultsShown = false;
            this.running = false;
            this.animationFrameId = null;
            this.lastFrameTime = 0;
            
            // Player physics
            this.player = { x: 80, y: 300, vx: 0, vy: 0, w: 44, h: 44, facing: 1, stunned: 0 };
            this.coins = 0;
            this.won = false;
            this.grounded = false;
            this.camX = 0;
            
            // Visual effects
            this.particles = [];
            this.trail = [];
            
            // Level data (cloned from level manager)
            const levelData = LevelManager.getLevelData();
            this.floors = levelData.floorSegments.map(f => ({...f}));
            this.platforms = levelData.platforms.map((p, i) => ({
                ...p, 
                h: 16,
                startX: p.x,
                dir: i % 2 === 0 ? 1 : -1,
                speed: 1 + Math.random() * 0.5,
                range: 60 + Math.random() * 40
            }));
            this.coinList = levelData.coins.map(c => ({...c, got: false, bob: Math.random() * 6.28}));
            this.obstacles = levelData.obstacles.map(o => ({
                ...o, 
                w: 48, 
                h: 48, 
                dir: 1, 
                spd: 2 + Math.random(), 
                range: 100 + Math.random() * 50,
                bitePhase: Math.random() * Math.PI * 2, // Fase de animación de mordedura
                biteSpeed: 0.15 + Math.random() * 0.1,  // Velocidad de mordedura
                lastBiteTime: 0                          // Tiempo de última mordedura
            }));
            this.finishX = levelData.length - 200;
        }

        init() {
            this.canvas = DOM.get(`canvas${this.num}`);
            this.ctx = this.canvas.getContext('2d', { alpha: false });
            
            const container = DOM.get(`screen${this.num}`);
            this.canvas.width = container.clientWidth;
            this.canvas.height = container.clientHeight;
            
            const ratio = this.canvas.height / 700;
            this.floorY = this.canvas.height - 70;
            
            // Scale level elements
            this.floors.forEach(f => f.y = this.floorY);
            this.platforms.forEach(p => p.y *= ratio);
            this.coinList.forEach(c => c.y *= ratio);
            this.obstacles.forEach(o => o.y *= ratio);
            this.player.y = 300 * ratio;
            
            // Cache DOM elements
            this.coinsEl = DOM.get(`coins${this.num}`);
            this.progressEl = DOM.get(`progress${this.num}`);
            
            this.running = true;
            this.loop();
        }

        update() {
            if (this.won || !GameManager.state.started) return;
            
            const p = this.player;
            const prevY = p.y;
            
            this._updatePlatforms();
            this._updateMovement(p);
            this._updatePhysics(p, prevY);
            this._updateObstacles(p);
            this._updateCoins(p);
            this._updateParticles();
            this._checkFinish(p);
        }
        
        _updatePlatforms() {
            this.platforms.forEach(pl => {
                pl.x += pl.dir * pl.speed;
                if (Math.abs(pl.x - pl.startX) > pl.range) {
                    pl.dir *= -1;
                }
            });
        }

        _updateMovement(p) {
            if (!p.stunned) {
                const targetVx = this.keys.left ? -PHYSICS.MOVE_SPEED : 
                                 this.keys.right ? PHYSICS.MOVE_SPEED : 0;
                const acceleration = this.grounded ? PHYSICS.GROUND_ACCELERATION : PHYSICS.AIR_ACCELERATION;
                
                if (targetVx !== 0) {
                    p.vx += (targetVx - p.vx) * acceleration;
                    p.facing = targetVx > 0 ? 1 : -1;
                } else if (this.grounded) {
                    p.vx *= PHYSICS.FRICTION;
                    if (Math.abs(p.vx) < 0.1) p.vx = 0;
                }
            } else {
                p.vx *= PHYSICS.AIR_RESISTANCE;
            }
            
            if (p.stunned > 0) p.stunned--;
            
            // Trail effect
            if (Math.abs(p.vx) > 1 || Math.abs(p.vy) > 3) {
                this.trail.push({ x: p.x, y: p.y, a: 0.4 });
                if (this.trail.length > 4) this.trail.shift();
            }
            
            for (let i = this.trail.length - 1; i >= 0; i--) {
                this.trail[i].a *= 0.85;
                if (this.trail[i].a <= 0.05) this.trail.splice(i, 1);
            }
        }

        _updatePhysics(p, prevY) {
            // Gravity
            p.vy += PHYSICS.GRAVITY;
            if (p.vy > PHYSICS.MAX_FALL_SPEED) p.vy = PHYSICS.MAX_FALL_SPEED;
            
            // Jump
            if (this.keys.jump && this.grounded && !p.stunned) {
                p.vy = PHYSICS.JUMP_POWER;
                AudioManager.play('jump');
                this.keys.jump = false;
                this._burst(p.x + p.w/2, p.y + p.h, '#8BC34A', 5);
            }
            
            // Variable jump height
            if (!this.keys.jump && p.vy < PHYSICS.JUMP_CUT_THRESHOLD) {
                p.vy *= PHYSICS.JUMP_CUT_MULTIPLIER;
            }
            
            // Apply movement
            p.x += p.vx;
            p.y += p.vy;
            
            // Collisions
            this.grounded = false;
            
            // Floor collision
            this.floors.forEach(f => {
                if (p.x + p.w > f.x + 2 && p.x < f.x + f.width - 2) {
                    if (p.vy >= 0 && prevY + p.h <= f.y + 5 && p.y + p.h >= f.y) {
                        p.y = f.y - p.h;
                        p.vy = 0;
                        this.grounded = true;
                    }
                }
            });
            
            // Platform collision
            this.platforms.forEach(pl => {
                if (p.x + p.w > pl.x + 2 && p.x < pl.x + pl.width - 2) {
                    if (p.vy >= 0 && prevY + p.h <= pl.y + 5 && p.y + p.h >= pl.y && p.y < pl.y + pl.h) {
                        p.y = pl.y - p.h;
                        p.vy = 0;
                        this.grounded = true;
                    }
                }
            });
            
            // Fall death
            if (p.y > this.canvas.height + 50) {
                this._burst(p.x + p.w/2, this.canvas.height - 50, '#AB3D8B', 12);
                p.x = 80;
                p.y = 300 * (this.canvas.height / 700);
                p.vx = p.vy = 0;
                AudioManager.play('hit');
            }
            
            // Bounds
            p.x = Math.max(0, p.x);
            
            // Camera
            this.camX = Math.max(0, Math.min(p.x - this.canvas.width / 2, this.finishX - this.canvas.width + 150));
            
            // Progress
            if (this.progressEl) {
                this.progressEl.style.width = Math.min(100, p.x / this.finishX * 100) + '%';
            }
        }

        _updateObstacles(p) {
            const now = performance.now();
            
            this.obstacles.forEach(o => {
                o.x += o.dir * o.spd;
                if (Math.abs(o.x - o.startX) > o.range) o.dir *= -1;
                
                // Animación de mordedura continua
                o.bitePhase += o.biteSpeed;
                
                // Mordedura agresiva cuando el jugador está cerca
                const distToPlayer = Math.abs((o.x + o.w/2) - (p.x + p.w/2));
                if (distToPlayer < 150) {
                    o.biteSpeed = 0.25; // Morder más rápido
                } else {
                    o.biteSpeed = 0.15; // Velocidad normal
                }
                
                // Culling
                if (Math.abs(o.x - p.x) > 200) return;
                
                // Collision
                const margin = 2;
                if (!p.stunned && 
                    p.x + p.w - margin > o.x && 
                    p.x + margin < o.x + o.w && 
                    p.y + p.h - margin > o.y && 
                    p.y + margin < o.y + o.h) {
                    p.stunned = 45;
                    AudioManager.play('hit');
                    this._burst(p.x + p.w/2, p.y + p.h/2, '#333', 8);
                    p.vy = -8;
                    p.vx = o.dir * -4;
                    // Activar mordedura en colisión
                    o.lastBiteTime = now;
                }
            });
        }

        _updateCoins(p) {
            this.coinList.forEach(c => {
                if (c.got) return;
                if (Math.abs(c.x - p.x) > 100) return;
                
                const dx = (p.x + p.w/2) - c.x;
                const dy = (p.y + p.h/2) - c.y;
                const distSq = dx * dx + dy * dy;
                
                if (distSq < 900) {
                    c.got = true;
                    this.coins++;
                    if (this.coinsEl) this.coinsEl.textContent = this.coins;
                    this._burst(c.x, c.y, '#EB8225', 8);
                    AudioManager.play('coin');
                }
            });
        }

        _updateParticles() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const pt = this.particles[i];
                pt.x += pt.vx;
                pt.y += pt.vy;
                pt.vy += 0.15;
                pt.life--;
                if (pt.life <= 0) this.particles.splice(i, 1);
            }
        }

        _checkFinish(p) {
            if (p.x > this.finishX && !this.won) {
                this.won = true;
                this.finishTime = Date.now();
                this._burst(p.x + p.w/2, p.y, '#73A03F', 20);
                
                if (!this.resultsShown) {
                    this.resultsShown = true;
                    const allDone = Object.values(GameManager.state.games).every(
                        g => g.won || GameManager.state.players[g.num].disconnected
                    );
                    if (allDone && !GameManager.state.resultsDisplayed) {
                        GameManager.state.resultsDisplayed = true;
                        setTimeout(() => GameManager.showResults(), 1200);
                    }
                }
            }
        }

        draw() {
            const ctx = this.ctx;
            const w = this.canvas.width;
            const h = this.canvas.height;
            
            this._drawBackground(ctx, w, h);
            
            ctx.save();
            ctx.translate(-this.camX, 0);
            
            this._drawClouds(ctx, w);
            this._drawFloors(ctx, w);
            this._drawPlatforms(ctx, w);
            this._drawObstacles(ctx, w);
            this._drawCoins(ctx, w);
            this._drawFinish(ctx);
            this._drawParticles(ctx);
            this._drawTrail(ctx);
            this._drawPlayer(ctx);
            
            ctx.restore();
        }

        _drawBackground(ctx, w, h) {
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, w, h * 0.4);
            ctx.fillStyle = '#98D8C8';
            ctx.fillRect(0, h * 0.4, w, h * 0.3);
            ctx.fillStyle = '#2D5A4A';
            ctx.fillRect(0, h * 0.7, w, h * 0.3);
        }

        _drawClouds(ctx, w) {
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            const clouds = [[100, 60], [400, 90], [800, 50], [1200, 80], [1700, 65], [2200, 75], [2700, 55]];
            clouds.forEach(([x, y]) => {
                if (x < this.camX - 100 || x > this.camX + w + 100) return;
                ctx.beginPath();
                ctx.arc(x, y, 30, 0, Math.PI * 2);
                ctx.arc(x + 25, y - 5, 22, 0, Math.PI * 2);
                ctx.arc(x + 50, y, 28, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        _drawFloors(ctx, w) {
            this.floors.forEach(f => {
                if (f.x + f.width < this.camX || f.x > this.camX + w) return;
                
                ctx.fillStyle = '#5D4037';
                ctx.fillRect(f.x, f.y, f.width, 70);
                ctx.fillStyle = '#8BC34A';
                ctx.fillRect(f.x, f.y, f.width, 12);
                ctx.fillStyle = '#9CCC65';
                for (let gx = f.x + 10; gx < f.x + f.width - 10; gx += 25) {
                    ctx.fillRect(gx, f.y - 4, 3, 8);
                }
            });
        }

        _drawPlatforms(ctx, w) {
            this.platforms.forEach(pl => {
                if (pl.x + pl.width < this.camX || pl.x > this.camX + w) return;
                
                ctx.fillStyle = '#546E7A';
                ctx.fillRect(pl.x, pl.y, pl.width, pl.h);
                ctx.fillStyle = '#78909C';
                ctx.fillRect(pl.x, pl.y, pl.width, 4);
            });
        }

        _drawObstacles(ctx, w) {
            this.obstacles.forEach(o => {
                if (o.x + o.w < this.camX || o.x > this.camX + w) return;
                
                const centerX = o.x + o.w / 2;
                const centerY = o.y + o.h / 2;
                const radius = o.w / 2 + 6;
                
                // Animación de mordedura
                const biteAnim = (Math.sin(o.bitePhase) + 1) / 2;
                const mouthAngle = 0.25 + biteAnim * 0.4;
                
                // Rebote
                const bounceY = Math.abs(Math.sin(o.bitePhase * 0.6)) * 4;
                
                ctx.save();
                ctx.translate(centerX, centerY - bounceY);
                
                // Voltear según dirección
                if (o.dir < 0) ctx.scale(-1, 1);
                
                // === CUERPO NEGRO (con boca estilo Pac-Man) ===
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(0, 0, radius, mouthAngle, Math.PI * 2 - mouthAngle);
                ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();
                
                // Brillo superior
                ctx.fillStyle = '#3a3a3a';
                ctx.beginPath();
                ctx.ellipse(-radius * 0.25, -radius * 0.35, radius * 0.4, radius * 0.2, -0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // === OJO ===
                const eyeX = -radius * 0.3;
                const eyeY = -radius * 0.25;
                const eyeR = radius * 0.35;
                
                // Ojo blanco
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, eyeR, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupila
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(eyeX + eyeR * 0.25, eyeY, eyeR * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Brillo ojo
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(eyeX, eyeY - eyeR * 0.3, eyeR * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }

        _drawCoins(ctx, w) {
            const t = performance.now();
            this.coinList.forEach(c => {
                if (c.got) return;
                if (c.x < this.camX - 50 || c.x > this.camX + w + 50) return;
                
                const bobY = Math.sin(t / 200 + c.bob) * 4;
                ctx.fillStyle = '#EB8225';
                ctx.beginPath();
                ctx.arc(c.x, c.y + bobY, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(c.x - 4, c.y + bobY - 4, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('$', c.x, c.y + bobY + 1);
            });
        }

        _drawFinish(ctx) {
            const fx = this.finishX;
            
            // Flag pole
            ctx.fillStyle = '#455A64';
            ctx.fillRect(fx, this.floorY - 130, 6, 130);
            
            // Flag
            ctx.fillStyle = '#73A03F';
            ctx.beginPath();
            ctx.moveTo(fx + 6, this.floorY - 130);
            ctx.lineTo(fx + 60, this.floorY - 105);
            ctx.lineTo(fx + 6, this.floorY - 80);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('META', fx + 33, this.floorY - 102);
            
            // Checkered pattern
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 2; j++) {
                    ctx.fillStyle = (i + j) % 2 ? '#333' : '#fff';
                    ctx.fillRect(fx - 40 + i * 12, this.floorY - 20 + j * 10, 12, 10);
                }
            }
        }

        _drawParticles(ctx) {
            this.particles.forEach(pt => {
                ctx.globalAlpha = pt.life / 30;
                ctx.fillStyle = pt.color;
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        _drawTrail(ctx) {
            this.trail.forEach(tr => {
                ctx.globalAlpha = tr.a * 0.5;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.roundRect(tr.x + 5, tr.y + 5, this.player.w - 10, this.player.h - 10, 8);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        _drawPlayer(ctx) {
            const p = this.player;
            const t = performance.now();
            
            if (p.stunned) ctx.globalAlpha = 0.4 + Math.sin(t / 40) * 0.3;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(p.x + p.w/2, p.y + p.h + 4, p.w/2 * 0.7, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.roundRect(p.x, p.y, p.w, p.h, 12);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.roundRect(p.x + 5, p.y + 4, p.w - 10, 12, 6);
            ctx.fill();
            
            // Eyes
            const eyeY = p.y + p.h * 0.38;
            const eyeX1 = p.x + p.w * 0.3;
            const eyeX2 = p.x + p.w * 0.7;
            const lookX = p.facing * 3;
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(eyeX1, eyeY, 7, 0, Math.PI * 2);
            ctx.arc(eyeX2, eyeY, 7, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(eyeX1 + lookX, eyeY, 3, 0, Math.PI * 2);
            ctx.arc(eyeX2 + lookX, eyeY, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1;
        }

        _burst(x, y, color, count) {
            const maxParticles = 150;
            const actualCount = Math.min(count, maxParticles - this.particles.length);
            
            for (let i = 0; i < actualCount; i++) {
                this.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 3,
                    life: 25 + Math.random() * 10,
                    color
                });
            }
        }

        resize(newWidth, newHeight) {
            const oldHeight = this.canvas.height;
            
            this.canvas.width = newWidth;
            this.canvas.height = newHeight;
            
            const oldRatio = oldHeight / 700;
            const newRatio = newHeight / 700;
            const scaleY = newRatio / oldRatio;
            
            this.floorY = newHeight - 70;
            
            this.floors.forEach(f => f.y = this.floorY);
            this.platforms.forEach(p => p.y *= scaleY);
            this.coinList.forEach(c => c.y *= scaleY);
            this.obstacles.forEach(o => o.y *= scaleY);
            this.player.y *= scaleY;
        }

        loop() {
            if (!this.running) return;
            
            const now = performance.now();
            const deltaTime = now - (this.lastFrameTime || now);
            this.lastFrameTime = now;
            
            const targetFrameTime = 1000 / 60;
            
            if (deltaTime >= targetFrameTime * 0.9) {
                this.update();
                this.draw();
            }
            
            this.animationFrameId = requestAnimationFrame(() => this.loop());
        }

        stop() {
            this.running = false;
            if (this.animationFrameId !== null) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }
        }
    }

    // ==========================================================================
    // GAME MANAGER
    // ==========================================================================
    
    const GameManager = {
        airconsole: null,
        isReady: false,
        pendingConnections: [],
        
        state: {
            players: {},
            games: {},
            started: false,
            starting: false,
            startTime: null,
            admin: null,
            resultsDisplayed: false
        },
        
        _setupEventListeners() {
            DOM.elements.nextLevelBtn.addEventListener('click', () => this.goToNextLevel());
            DOM.elements.levelSelectBtn.addEventListener('click', () => this.restart());
            
            let resizeTimeout;
            window.addEventListener('resize', () => {
                if (this.state.started) {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        for (let n in this.state.games) {
                            const g = this.state.games[n];
                            const container = DOM.get(`screen${n}`);
                            if (container && g.canvas) {
                                g.resize(container.clientWidth, container.clientHeight);
                            }
                        }
                    }, 100);
                }
            });
        },
        
        _handleConnect(id) {
            // Ignore screen device (id = 0)
            if (id === AirConsole.SCREEN || id === 0) return;
            
            // If not ready yet, queue the connection for later
            if (!this.isReady) {
                this.pendingConnections.push(id);
                return;
            }
            
            // Check if this device is already connected (reconnection)
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (this.state.players[slot] && this.state.players[slot].deviceId === id) {
                    // Device reconnecting to same slot - always mark as connected and send message
                    this.state.players[slot].disconnected = false;
                    
                    // Send reconnect message immediately
                    airconsole.message(id, {
                        action: 'reconnected',
                        playerNum: slot,
                        color: this.state.players[slot].color,
                        colorName: this.state.players[slot].name,
                        isAdmin: this.state.players[slot].isAdmin
                    });
                    
                    UIManager.updatePlayerSlots(this.state.players, this.state.admin);
                    
                    // Delay broadcast to ensure device is fully registered
                    setTimeout(function() {
                        airconsole.broadcast({ action: 'gameState', players: GameManager.state.players });
                    }, 100);
                    
                    return;
                }
            }
            
            // Check if game is full before allowing join
            let availableSlots = 0;
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (!this.state.players[slot]) {
                    availableSlots++;
                }
            }
            
            if (availableSlots === 0) {
                // Game is full
                airconsole.message(id, { action: 'gameFull' });
                return;
            }
            
            // Send message to controller that they can join (but don't assign yet)
            airconsole.message(id, { action: 'canJoin' });
        },
        
        _handleDisconnect(id) {
            // Find player by device ID
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (this.state.players[slot] && this.state.players[slot].deviceId === id) {
                    this.state.players[slot].disconnected = true;
                    UIManager.updatePlayerSlots(this.state.players, this.state.admin);
                    
                    GameManager.airconsole.broadcast({ 
                        action: 'playerDisconnected', 
                        playerNum: slot,
                        playerName: this.state.players[slot].name
                    });
                    return;
                }
            }
        },
        
        _handleMessage(id, data) {
            // Find player slot by device ID
            let playerSlot = null;
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (this.state.players[slot] && this.state.players[slot].deviceId === id) {
                    playerSlot = slot;
                    break;
                }
            }
            
            switch (data.action) {
                case 'requestJoin':
                    this._handleRequestJoin(id);
                    break;
                    
                case 'join':
                    this._handleJoinRequest(id, playerSlot);
                    break;
                    
                case 'selectColor':
                    this._handleColorSelect(id, data);
                    break;
                    
                case 'startGame':
                    if (playerSlot === this.state.admin) this.startGame();
                    break;
                    
                case 'playAgain':
                    if (playerSlot === this.state.admin) this.restart();
                    break;
                    
                case 'nextLevel':
                    if (playerSlot === this.state.admin) this.goToNextLevel();
                    break;
                    
                case 'goToLevelSelect':
                    if (playerSlot === this.state.admin) this.restart();
                    break;
                    
                case 'move':
                case 'stop':
                case 'jump':
                    this._handleGameInput(playerSlot, data);
                    break;
            }
        },
        
        _handleRequestJoin(id) {
            // Check if this device is already assigned
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (this.state.players[slot] && this.state.players[slot].deviceId === id) {
                    // Already joined - send joined message
                    const p = this.state.players[slot];
                    airconsole.message(id, {
                        action: 'joined',
                        playerNum: slot,
                        color: p.color,
                        colorName: p.name,
                        isAdmin: p.isAdmin
                    });
                    return;
                }
            }
            
            // Check if game is full
            let availableSlots = 0;
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (!this.state.players[slot]) {
                    availableSlots++;
                }
            }
            
            if (availableSlots === 0) {
                // Game is full
                airconsole.message(id, { action: 'gameFull' });
                return;
            }
            
            // Send canJoin message
            airconsole.message(id, { action: 'canJoin' });
        },
        
        _handleJoinRequest(id, playerSlot) {
            // If player is already assigned, just resend the joined message
            if (playerSlot && this.state.players[playerSlot]) {
                const p = this.state.players[playerSlot];
                airconsole.message(id, {
                    action: 'joined',
                    playerNum: playerSlot,
                    color: p.color,
                    colorName: p.name,
                    isAdmin: p.isAdmin
                });
                return;
            }
            
            // New player wants to join - assign them a slot
            // Check if game is full
            let availableSlot = null;
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (!this.state.players[slot]) {
                    availableSlot = slot;
                    break;
                }
            }
            
            if (availableSlot === null) {
                // Game is full
                airconsole.message(id, { action: 'gameFull' });
                return;
            }
            
            // Assign player to slot
            const playerIndex = availableSlot - 1;
            const isAdmin = !this.state.admin;
            if (isAdmin) this.state.admin = availableSlot;
            
            this.state.players[availableSlot] = {
                deviceId: id,
                playerNumber: playerIndex,
                name: CONFIG.NAMES[playerIndex],
                color: CONFIG.COLORS[playerIndex],
                isAdmin: isAdmin,
                disconnected: false
            };
            
            // Send joined message to controller
            airconsole.message(id, {
                action: 'joined',
                playerNum: availableSlot,
                color: CONFIG.COLORS[playerIndex],
                colorName: CONFIG.NAMES[playerIndex],
                isAdmin: isAdmin
            });
            
            UIManager.updatePlayerSlots(this.state.players, this.state.admin);
            
            // Delay broadcast to ensure device is fully registered
            setTimeout(function() {
                airconsole.broadcast({ action: 'gameState', players: GameManager.state.players });
            }, 100);
        },
        
        _handleColorSelect(id, data) {
            for (let n in this.state.players) {
                if (this.state.players[n].deviceId === id) {
                    this.state.players[n].color = data.color;
                    this.state.players[n].name = data.colorName;
                    UIManager.updatePlayerSlots(this.state.players, this.state.admin);
                    GameManager.airconsole.message(id, { action: 'colorUpdated', color: data.color, colorName: data.colorName });
                    break;
                }
            }
        },
        
        _handleGameInput(playerSlot, data) {
            if (playerSlot && this.state.games[playerSlot] && this.state.started) {
                const g = this.state.games[playerSlot];
                
                if (data.action === 'move') {
                    g.keys.left = data.direction === 'left';
                    g.keys.right = data.direction === 'right';
                } else if (data.action === 'stop') {
                    g.keys.left = g.keys.right = false;
                } else if (data.action === 'jump') {
                    g.keys.jump = data.pressed;
                }
            }
        },
        
        async startGame() {
            if (this.state.started || this.state.starting) return;
            this.state.starting = true;
            
            DOM.elements.startScreen.style.display = 'none';
            DOM.elements.gameContainer.style.display = 'block';
            
            const players = Object.values(this.state.players).filter(p => !p.disconnected);
            this._setupScreens(players.length);
            
            for (let n in this.state.players) {
                if (!this.state.players[n].disconnected) {
                    this.state.games[n] = new Game(n, this.state.players[n].color, this.state.players[n].name);
                    this.state.games[n].init();
                }
            }
            
            await UIManager.countdown();
            
            this.state.started = true;
            this.state.starting = false;
            this.state.startTime = Date.now();
            GameManager.airconsole.broadcast({ action: 'gameStart' });
        },
        
        _setupScreens(count) {
            const container = DOM.elements.gameContainer;
            container.innerHTML = '';
            
            let i = 0;
            for (let n in this.state.players) {
                if (this.state.players[n].disconnected) continue;
                const p = this.state.players[n];
                
                const div = document.createElement('div');
                div.id = `screen${n}`;
                div.className = 'absolute overflow-hidden';
                
                // Improved Layout with better spacing
                if (count === 1) {
                    div.style.cssText = 'inset:0;';
                } else if (count === 2) {
                    div.style.cssText = `left:0;right:0;height:calc(50% - 4px);${i === 0 ? 'top:0' : 'bottom:0'};`;
                } else if (count === 3) {
                    if (i === 0) div.style.cssText = 'top:0;left:0;right:0;height:calc(50% - 4px);';
                    else div.style.cssText = `bottom:0;width:calc(50% - 4px);height:calc(50% - 4px);${i === 1 ? 'left:0' : 'right:0'};`;
                } else {
                    const pos = [['top:0;left:0'], ['top:0;right:0'], ['bottom:0;left:0'], ['bottom:0;right:0']][i];
                    div.style.cssText = `${pos};width:calc(50% - 4px);height:calc(50% - 4px);`;
                }
                
                const levelData = LevelManager.getLevelData();
                div.innerHTML = `
                    <canvas id="canvas${n}" class="absolute inset-0 w-full h-full"></canvas>
                    <div class="absolute top-2 left-2 bg-black/70 rounded-lg py-1 px-3 flex items-center gap-2 text-white font-bold text-xs z-10" style="border-left:3px solid ${p.color}">
                        <iconify-icon icon="mdi:cash-multiple" class="text-steam-naranja text-sm"></iconify-icon>
                        <span id="coins${n}">0</span>/<span>${levelData.coins.length}</span>
                    </div>
                    <div class="absolute top-2 right-2 bg-black/70 rounded-lg py-1 px-2 flex items-center gap-1.5 font-bold z-10" style="border-left:3px solid ${p.color}">
                        <div class="w-5 h-5 rounded-md relative" style="background:${p.color}">
                            <span class="absolute top-1 left-1 w-1 h-1 bg-white rounded-full"></span>
                            <span class="absolute top-1 right-1 w-1 h-1 bg-white rounded-full"></span>
                        </div>
                        <span class="text-white text-xs">${p.name}</span>
                    </div>
                    <div class="absolute bottom-2 left-2 right-2 flex items-center gap-2 z-10">
                        <div class="flex-1 h-1.5 bg-black/30 rounded-full overflow-hidden">
                            <div id="progress${n}" class="h-full rounded-full transition-all" style="width:0%;background:${p.color}"></div>
                        </div>
                        <div class="bg-black/70 rounded-md px-1.5 py-0.5 text-white text-xs font-bold">
                            Nv${LevelManager.progress.currentLevel}
                        </div>
                    </div>
                `;
                
                if (count > 1) {
                    div.style.border = `3px solid ${p.color}`;
                }
                
                container.appendChild(div);
                i++;
            }
        },
        
        showResults() {
            const results = [];
            
            for (let n in this.state.games) {
                const g = this.state.games[n];
                const p = this.state.players[n];
                if (g.finishTime && !p.disconnected) {
                    const timeBonus = Math.max(0, 1000 - (g.finishTime - this.state.startTime) / 100);
                    const coinBonus = g.coins * 100;
                    results.push({
                        num: n,
                        name: p.name,
                        color: p.color,
                        coins: g.coins,
                        time: ((g.finishTime - this.state.startTime) / 1000).toFixed(1),
                        score: Math.round(timeBonus + coinBonus)
                    });
                }
            }
            
            results.sort((a, b) => b.score - a.score);
            
            const levelCompleted = results.length > 0;
            if (levelCompleted) {
                LevelManager.completeLevel(LevelManager.progress.currentLevel);
            }
            
            UIManager.showResults(results, levelCompleted, LevelManager.hasNextLevel());
            
            GameManager.airconsole.broadcast({ 
                action: 'gameResults', 
                results, 
                winner: results[0], 
                levelCompleted, 
                hasNextLevel: LevelManager.hasNextLevel() 
            });
        },
        
        restart() {
            if (!this.state.resultsDisplayed) return;
            
            DOM.elements.resultsScreen.style.display = 'none';
            DOM.elements.startScreen.style.display = 'flex';
            DOM.elements.gameContainer.style.display = 'none';
            
            // Stop all games
            for (let n in this.state.games) {
                if (this.state.games[n]?.stop) {
                    this.state.games[n].stop();
                }
            }
            
            this.state.started = false;
            this.state.starting = false;
            this.state.games = {};
            this.state.resultsDisplayed = false;
            
            // Remove disconnected players
            for (let n in this.state.players) {
                if (this.state.players[n].disconnected) {
                    delete this.state.players[n];
                }
            }
            
            UIManager.updatePlayerSlots(this.state.players, this.state.admin);
            LevelManager.updateButtons();
            GameManager.airconsole.broadcast({ action: 'gameRestart' });
        },
        
        goToNextLevel() {
            if (!this.state.resultsDisplayed) return;
            
            const nextLevel = LevelManager.progress.currentLevel + 1;
            if (nextLevel <= 5) {
                LevelManager.selectLevel(nextLevel);
                this.restart();
            }
        }
    };

    // ==========================================================================
    // INITIALIZATION (following AirConsole quick-start pattern)
    // ==========================================================================
    
    // Initialize DOM
    DOM.init();
    
    // Create AirConsole instance
    var airconsole = new AirConsole();
    GameManager.airconsole = airconsole;
    
    // AirConsole ready handler
    airconsole.onReady = function() {
        GameManager.isReady = true;
        
        // Process any connections that arrived before ready
        GameManager.pendingConnections.forEach(function(id) {
            GameManager._handleConnect(id);
        });
        GameManager.pendingConnections = [];
    };
    
    // Handle new device connections
    airconsole.onConnect = function(device_id) {
        GameManager._handleConnect(device_id);
    };
    
    // Handle device disconnections
    airconsole.onDisconnect = function(device_id) {
        GameManager._handleDisconnect(device_id);
    };
    
    // Listen for messages from controllers
    airconsole.onMessage = function(from, data) {
        if (data && data.action) {
            GameManager._handleMessage(from, data);
        }
    };
    
    // Setup UI and level selector
    GameManager._setupEventListeners();
    LevelManager.init();
    
    // ==========================================================================
    // KEYBOARD CONTROLS FOR PC TESTING
    // ==========================================================================
    
    const KeyboardControls = {
        enabled: true,
        activePlayer: null,
        
        init() {
            window.addEventListener('keydown', (e) => this._handleKey(e, true));
            window.addEventListener('keyup', (e) => this._handleKey(e, false));
        },
        
        _getActivePlayer() {
            // Find first connected player
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (GameManager.state.players[slot] && !GameManager.state.players[slot].disconnected) {
                    return slot;
                }
            }
            return null;
        },
        
        _handleKey(e, pressed) {
            if (!this.enabled || !GameManager.state.started) return;
            
            const playerSlot = this._getActivePlayer();
            if (!playerSlot || !GameManager.state.games[playerSlot]) return;
            
            const game = GameManager.state.games[playerSlot];
            
            // Arrow keys or WASD
            switch (e.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    e.preventDefault();
                    if (pressed) {
                        game.keys.left = true;
                        game.keys.right = false;
                    } else {
                        game.keys.left = false;
                    }
                    break;
                    
                case 'ArrowRight':
                case 'KeyD':
                    e.preventDefault();
                    if (pressed) {
                        game.keys.right = true;
                        game.keys.left = false;
                    } else {
                        game.keys.right = false;
                    }
                    break;
                    
                case 'ArrowUp':
                case 'KeyW':
                case 'Space':
                    e.preventDefault();
                    game.keys.jump = pressed;
                    break;
            }
        }
    };
    
    KeyboardControls.init();
    </script>
</body>
</html>
