<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>STEAM Platformer - Fundacion STEAM RD</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
    <script type="text/javascript" src="https://www.airconsole.com/api/airconsole-1.9.0.js"></script>
    
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        steam: {
                            turquesa: '#0595AE',
                            morado: '#AB3D8B',
                            naranja: '#EB8225',
                            verde: '#73A03F',
                            negro: '#010101',
                            blanco: '#FFFFFF'
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        /* ==========================================================================
           BASE STYLES
           ========================================================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            position: fixed;
            top: 0;
            left: 0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #f8f9fa;
        }

        /* ==========================================================================
           TITLE STYLES
           ========================================================================== */
        .title-steam { color: #0595AE; }
        .title-platformer { color: #73A03F; }

        /* ==========================================================================
           PLAYER AVATAR
           ========================================================================== */
        .player-avatar {
            width: clamp(50px, 8vw, 80px);
            height: clamp(50px, 8vw, 80px);
            border-radius: 16px;
            position: relative;
            box-shadow: 0 6px 0 rgba(0,0,0,0.15), 0 8px 25px rgba(0,0,0,0.1);
        }

        .player-avatar::before,
        .player-avatar::after {
            content: '';
            position: absolute;
            width: 24%;
            height: 24%;
            top: 32%;
            background: radial-gradient(circle at 50% 50%, #222 35%, transparent 36%), white;
            border-radius: 50%;
            animation: idleBlink 4s ease-in-out infinite;
        }
        
        .player-avatar::before { left: 18%; }
        .player-avatar::after { right: 18%; animation-delay: 0.05s; }

        .player-avatar-small {
            width: clamp(35px, 5vw, 50px);
            height: clamp(35px, 5vw, 50px);
            border-radius: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.15);
        }

        /* ==========================================================================
           PLAYER CARD
           ========================================================================== */
        .player-card {
            background: white;
            border-radius: 20px;
            padding: clamp(16px, 3vw, 28px);
            border: 4px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .player-card.ready {
            border-color: #73A03F;
            background: #f0fdf4;
        }

        .player-card.admin {
            border-color: #EB8225;
            background: #fff7ed;
        }

        /* Player card ready/admin animations */
        .player-card.ready .player-avatar::before,
        .player-card.ready .player-avatar::after,
        .player-card.admin .player-avatar::before,
        .player-card.admin .player-avatar::after {
            animation: blinkHappy 0.6s ease-out, idleBlink 4s ease-in-out 0.6s infinite;
        }

        .player-card.ready .player-avatar,
        .player-card.admin .player-avatar {
            animation: happyJump 0.5s ease-out;
        }

        /* ==========================================================================
           COUNTDOWN
           ========================================================================== */
        .countdown-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .countdown-number {
            font-size: clamp(120px, 30vw, 250px);
            font-weight: 900;
            color: white;
            text-shadow: 0 0 60px currentColor;
            animation: countPop 0.6s ease-out;
        }

        /* ==========================================================================
           ANIMATIONS
           ========================================================================== */
        @keyframes idleBlink {
            0%, 42%, 48%, 100% { transform: scaleY(1); }
            45% { transform: scaleY(0.05); }
        }

        @keyframes blinkHappy {
            0% { transform: scaleY(1); }
            20% { transform: scaleY(0.05); }
            40% { transform: scaleY(1); }
            60% { transform: scaleY(0.05); }
            80%, 100% { transform: scaleY(1); }
        }

        @keyframes happyJump {
            0% { transform: scale(1); }
            40% { transform: scale(1.15) translateY(-12px); }
            70% { transform: scale(0.95) translateY(0); }
            100% { transform: scale(1) translateY(0); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        .float { animation: float 3s ease-in-out infinite; }

        @keyframes countPop {
            0% { transform: scale(2.5); opacity: 0; }
            60% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes fall {
            to { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        
        .confetti {
            position: absolute;
            animation: fall 3s ease-out forwards;
        }

        @keyframes pulse { 50% { opacity: 0.6; } }
        .pulse { animation: pulse 2s ease infinite; }

        @keyframes winner {
            0% { transform: scale(0) rotate(-10deg); }
            70% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        .winner-anim { animation: winner 0.6s ease-out; }

        /* ==========================================================================
           LIVE RANKING OVERLAY STYLES
           ========================================================================== */
        .overlay-backdrop {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ranking-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            border-radius: 24px;
            padding: clamp(20px, 4vw, 32px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            0% {
                transform: translate(-50%, -60%);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        .winner-title {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .position-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: white;
            border-radius: 12px;
            border-left: 4px solid;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .continue-message {
            animation: pulse 2s ease infinite;
        }
    </style>
</head>
<body>
    <!-- START SCREEN -->
    <div id="startScreen" class="w-screen h-screen flex flex-col items-center justify-center p-6 text-center bg-gray-50">
        <div class="mb-6">
            <h1 class="text-4xl sm:text-5xl lg:text-6xl font-black mb-2 flex items-center justify-center gap-3">
                <iconify-icon icon="mdi:gamepad-variant" class="text-steam-turquesa"></iconify-icon>
                <span class="title-steam">STEAM</span> <span class="title-platformer">PLATFORMER</span>
            </h1>
            <p class="text-gray-500 text-lg flex items-center justify-center gap-3">
                <iconify-icon icon="mdi:run-fast"></iconify-icon>
                Corre
                <iconify-icon icon="mdi:arrow-up-bold-box"></iconify-icon>
                Salta
                <iconify-icon icon="mdi:cash-multiple"></iconify-icon>
                Colecta
            </p>
        </div>
        
        <div class="grid grid-cols-2 gap-4 sm:gap-6 mb-8 w-full max-w-xl lg:max-w-3xl">
            <div class="player-card" id="playerSlot1">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 1
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
            <div class="player-card" id="playerSlot2">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 2
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
            <div class="player-card" id="playerSlot3">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 3
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
            <div class="player-card" id="playerSlot4">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 4
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
        </div>
        
        <div class="bg-steam-naranja/10 border-2 border-steam-naranja rounded-2xl py-4 px-8 hidden flex items-center gap-3" id="adminHint">
            <iconify-icon icon="mdi:cellphone" class="text-steam-naranja text-2xl"></iconify-icon>
            <p class="text-steam-naranja font-bold">El Jugador 1 inicia desde su telefono</p>
        </div>
        
        <!-- Level Selection -->
        <div class="mt-6 hidden" id="levelSelector">
            <h3 class="text-lg font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                <iconify-icon icon="mdi:map-marker-path"></iconify-icon>
                Selecciona Nivel
            </h3>
            <div class="flex gap-2 justify-center flex-wrap max-w-md mx-auto">
                <button class="level-btn bg-steam-verde text-white font-bold py-2 px-4 rounded-xl border-2 border-steam-verde" data-level="1">1</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="2">2</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="3">3</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="4">4</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="5">5</button>
            </div>
            <p class="text-sm text-gray-500 mt-2 text-center" id="levelName">Inicio Facil</p>
        </div>
    </div>

    <!-- GAME CONTAINER -->
    <div id="gameContainer" class="hidden w-screen h-screen fixed inset-0 overflow-hidden"></div>

    <!-- COUNTDOWN -->
    <div id="countdownOverlay" class="countdown-overlay hidden">
        <div class="countdown-number" id="countdownNumber">3</div>
    </div>

    <!-- RESULTS SCREEN -->
    <div id="resultsScreen" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4 bg-gray-50">
        <div class="bg-white rounded-3xl p-6 sm:p-10 text-center w-full max-w-2xl shadow-2xl max-h-[95vh] overflow-y-auto">
            <h2 class="text-3xl sm:text-4xl font-black text-steam-turquesa mb-6 flex items-center justify-center gap-3">
                <iconify-icon icon="mdi:flag-checkered"></iconify-icon>
                Fin de Carrera!
            </h2>
            <div class="winner-anim mb-8" id="winnerSection"></div>
            <table class="w-full mb-8 text-left">
                <thead>
                    <tr class="border-b-4 border-gray-100">
                        <th class="py-3 px-2 text-steam-turquesa font-bold">#</th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold">
                            <span class="flex items-center gap-1">
                                <iconify-icon icon="mdi:account"></iconify-icon>
                                Jugador
                            </span>
                        </th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold text-center">
                            <span class="flex items-center justify-center gap-1">
                                <iconify-icon icon="mdi:cash"></iconify-icon>
                                Monedas
                            </span>
                        </th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold text-center">
                            <span class="flex items-center justify-center gap-1">
                                <iconify-icon icon="mdi:timer"></iconify-icon>
                                Tiempo
                            </span>
                        </th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold text-right">
                            <span class="flex items-center justify-end gap-1">
                                <iconify-icon icon="mdi:star"></iconify-icon>
                                Puntos
                            </span>
                        </th>
                    </tr>
                </thead>
                <tbody id="resultsBody"></tbody>
            </table>
            <div class="flex gap-4" id="resultsActions">
                <button class="btn btn-turquesa py-4 px-8 text-base hidden pulse flex items-center gap-2" id="nextLevelBtn">
                    <iconify-icon icon="mdi:arrow-right-bold"></iconify-icon>
                    SIGUIENTE NIVEL
                </button>
                <button class="btn btn-morado py-4 px-8 text-base hidden pulse flex items-center gap-2" id="levelSelectBtn">
                    <iconify-icon icon="mdi:map-marker-path"></iconify-icon>
                    SELECCIONAR NIVEL
                </button>
            </div>
            <div class="bg-steam-naranja/10 border-2 border-steam-naranja rounded-xl py-4 px-6 pulse flex items-center justify-center gap-2" id="waitingAdmin">
                <iconify-icon icon="mdi:cellphone" class="text-steam-naranja text-xl"></iconify-icon>
                <p class="text-steam-naranja font-bold">Esperando al Jugador 1...</p>
            </div>
        </div>
    </div>

    <!-- LIVE RANKING OVERLAY -->
    <div id="liveRankingOverlay" class="hidden fixed inset-0 z-[60] overlay-backdrop">
        <div class="ranking-panel">
            <div class="mb-6">
                <h2 class="winner-title text-3xl sm:text-4xl font-black mb-4 flex items-center justify-center gap-3">
                    üèÜ ¬°Primer Lugar!
                </h2>
                <div id="winnerInfo" class="flex flex-col items-center gap-3">
                    <!-- Winner info will be populated dynamically -->
                </div>
            </div>
            <div class="mb-4">
                <h3 class="text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:format-list-numbered"></iconify-icon>
                    Clasificaci√≥n en Vivo
                </h3>
                <div id="livePositionList" class="space-y-2">
                    <!-- Position items will be populated dynamically -->
                </div>
            </div>
            <div class="continue-message text-center text-sm text-gray-600 mt-4">
                <iconify-icon icon="mdi:run-fast"></iconify-icon>
                Los dem√°s jugadores contin√∫an compitiendo...
            </div>
        </div>
    </div>

    <!-- CONFETTI -->
    <div class="fixed inset-0 pointer-events-none z-[1000] overflow-hidden" id="confettiContainer"></div>

    <script>
    /**
     * STEAM Platformer - Screen Controller
     * 
     * Manages game state, player connections, physics, and game rendering.
     * Broadcasts game events to controllers via AirConsole.
     * 
     * @fileoverview Main game screen module for the STEAM Platformer
     * @version 2.0.0
     */

    // ==========================================================================
    // CONFIGURATION
    // ==========================================================================
    
    const CONFIG = {
        MAX_PLAYERS: 4,
        COLORS: ['#73A03F', '#AB3D8B', '#0595AE', '#EB8225'],
        NAMES: ['Verde', 'Morado', 'Turquesa', 'Naranja'],
        CONFETTI_COLORS: ['#0595AE', '#AB3D8B', '#EB8225', '#73A03F', '#FFD700'],
        CONFETTI_COUNT: 150
    };

    const PHYSICS = {
        GRAVITY: 0.6,
        MAX_FALL_SPEED: 18,
        MOVE_SPEED: 7,
        JUMP_POWER: -28,
        AIR_ACCELERATION: 0.7,
        GROUND_ACCELERATION: 0.85,
        FRICTION: 0.7,
        AIR_RESISTANCE: 0.95,
        JUMP_CUT_MULTIPLIER: 0.5,
        JUMP_CUT_THRESHOLD: -5,
        COYOTE_TIME: 6,
        JUMP_BUFFER: 8
    };

    // ==========================================================================
    // LEVEL THEMES
    // ==========================================================================
    
    const LEVEL_THEMES = {
        1: {
            name: "Pradera Verde",
            sky: ['#87CEEB', '#B0E0E6', '#98D8C8'],
            platform: ['#8B7355', '#A0826D'],
            floor: ['#5D4037', '#8BC34A'],
            clouds: 'rgba(255,255,255,0.9)',
            accent: '#73A03F',
            decorations: 'flowers'
        },
        2: {
            name: "Desierto Dorado",
            sky: ['#FFD89B', '#FFA07A', '#FF8C69'],
            platform: ['#D2691E', '#CD853F'],
            floor: ['#C19A6B', '#DEB887'],
            clouds: 'rgba(255,248,220,0.85)',
            accent: '#EB8225',
            decorations: 'cacti'
        },
        3: {
            name: "Monta√±a Nevada",
            sky: ['#B0C4DE', '#87CEEB', '#778899'],
            platform: ['#708090', '#778899'],
            floor: ['#696969', '#F0F8FF'],
            clouds: 'rgba(255,255,255,0.95)',
            accent: '#0595AE',
            decorations: 'snow'
        },
        4: {
            name: "Volc√°n Oscuro",
            sky: ['#2F1B1B', '#4A2020', '#5C3333'],
            platform: ['#3D2817', '#4E3620'],
            floor: ['#1C1C1C', '#8B0000'],
            clouds: 'rgba(139,0,0,0.6)',
            accent: '#AB3D8B',
            decorations: 'lava'
        },
        5: {
            name: "Cielo M√≠stico",
            sky: ['#4B0082', '#6A0DAD', '#8A2BE2'],
            platform: ['#FFD700', '#FFA500'],
            floor: ['#9370DB', '#BA55D3'],
            clouds: 'rgba(255,215,0,0.3)',
            accent: '#FFD700',
            decorations: 'stars'
        }
    };

    // ==========================================================================
    // LEVEL DATA
    // ==========================================================================
    
    /*
     * Level Validation Table
     * 
     * Quick reference for level design integrity:
     * 
     * | Level | Max Floor Gap | Max Platform Gap | Reachable Status |
     * |-------|---------------|------------------|------------------|
     * | 1     | ‚â§200px        | ‚â§180px           | All reachable    |
     * | 2     | ‚â§200px        | ‚â§180px           | All reachable    |
     * | 3     | ‚â§200px        | ‚â§180px           | All reachable    |
     * | 4     | ‚â§200px        | ‚â§180px           | All reachable    |
     * | 5     | ‚â§200px        | ‚â§180px           | All reachable    |
     * 
     * Design Rules:
     * - Floor segment gaps must be ‚â§200px (max jump distance)
     * - Platform gaps must be ‚â§180px with vertical spacing 100-140px
     * - All coins must be accessible (on platforms, jump arcs, or ground)
     * - Obstacles positioned at y>250px with adequate reaction space
     * - Progressive difficulty maintained from level 1 to 5
     * 
     * Update this table whenever level data changes.
     */
    
    const LEVELS = {
        1: {
            name: "Inicio Facil",
            length: 3000,
            floorSegments: [
                { x: 0, width: 700 },
                { x: 850, width: 600 },
                { x: 1600, width: 650 },
                { x: 2400, width: 600 }
            ],
            platforms: [
                { x: 500, y: 420, width: 200 },
                { x: 900, y: 360, width: 180 },
                { x: 1200, y: 400, width: 200 },
                { x: 1700, y: 380, width: 180 },
                { x: 2100, y: 350, width: 200 }
            ],
            coins: [
                { x: 600, y: 380 }, { x: 1000, y: 320 }, { x: 1300, y: 360 },
                { x: 1800, y: 340 }, { x: 2200, y: 310 }, { x: 2800, y: 550 }
            ],
            obstacles: [
                { x: 750, y: 280, startX: 750 },
                { x: 1800, y: 270, startX: 1800 }
            ]
        },
        2: {
            name: "Saltos Medianos",
            length: 3800,
            floorSegments: [
                { x: 0, width: 500 },
                { x: 650, width: 400 },
                { x: 1200, width: 500 },
                { x: 1850, width: 450 },
                { x: 2550, width: 600 },
                { x: 3300, width: 500 }
            ],
            platforms: [
                { x: 400, y: 420, width: 180 },
                { x: 700, y: 360, width: 160 },
                { x: 950, y: 400, width: 200 },
                { x: 1300, y: 340, width: 170 },
                { x: 1600, y: 380, width: 190 },
                { x: 1950, y: 320, width: 160 },
                { x: 2250, y: 360, width: 200 },
                { x: 2650, y: 400, width: 180 },
                { x: 3000, y: 350, width: 170 }
            ],
            coins: [
                { x: 490, y: 380 }, { x: 790, y: 320 }, { x: 1050, y: 360 },
                { x: 1390, y: 300 }, { x: 1690, y: 340 }, { x: 2040, y: 280 },
                { x: 2340, y: 320 }, { x: 2740, y: 360 }, { x: 3600, y: 550 }
            ],
            obstacles: [
                { x: 650, y: 260, startX: 650 },
                { x: 1350, y: 270, startX: 1350 },
                { x: 2150, y: 265, startX: 2150 },
                { x: 2950, y: 275, startX: 2950 }
            ]
        },
        3: {
            name: "Torre Alta",
            length: 4500,
            floorSegments: [
                { x: 0, width: 450 },
                { x: 650, width: 350 },
                { x: 1200, width: 300 },
                { x: 1750, width: 400 },
                { x: 2400, width: 350 },
                { x: 3000, width: 500 },
                { x: 3750, width: 150 }
            ],
            platforms: [
                { x: 350, y: 420, width: 160 },
                { x: 600, y: 380, width: 150 },
                { x: 850, y: 340, width: 140 },
                { x: 1100, y: 360, width: 160 },
                { x: 1400, y: 320, width: 170 },
                { x: 1700, y: 280, width: 150 },
                { x: 2000, y: 400, width: 180 },
                { x: 2300, y: 350, width: 160 },
                { x: 2650, y: 310, width: 170 },
                { x: 2950, y: 370, width: 180 },
                { x: 3300, y: 410, width: 190 },
                { x: 3650, y: 360, width: 170 }
            ],
            coins: [
                { x: 430, y: 380 }, { x: 680, y: 340 }, { x: 930, y: 300 },
                { x: 1180, y: 320 }, { x: 1480, y: 280 }, { x: 1780, y: 240 },
                { x: 2090, y: 360 }, { x: 2390, y: 310 }, { x: 2740, y: 270 },
                { x: 3040, y: 330 }, { x: 3390, y: 370 }, { x: 3730, y: 320 }
            ],
            obstacles: [
                { x: 550, y: 260, startX: 550 },
                { x: 1150, y: 270, startX: 1150 },
                { x: 1850, y: 265, startX: 1850 },
                { x: 2600, y: 275, startX: 2600 },
                { x: 3350, y: 280, startX: 3350 },
                { x: 4100, y: 270, startX: 4100 }
            ]
        },
        4: {
            name: "Abismo Peligroso",
            length: 5200,
            floorSegments: [
                { x: 0, width: 400 },
                { x: 600, width: 300 },
                { x: 1100, width: 350 },
                { x: 1650, width: 300 },
                { x: 2200, width: 400 },
                { x: 2850, width: 300 },
                { x: 3400, width: 350 },
                { x: 4000, width: 350 }
            ],
            platforms: [
                { x: 300, y: 420, width: 150 },
                { x: 550, y: 380, width: 130 },
                { x: 800, y: 340, width: 140 },
                { x: 1050, y: 360, width: 150 },
                { x: 1350, y: 400, width: 160 },
                { x: 1650, y: 360, width: 140 },
                { x: 1950, y: 320, width: 150 },
                { x: 2250, y: 380, width: 160 },
                { x: 2600, y: 340, width: 150 },
                { x: 2900, y: 380, width: 140 },
                { x: 3200, y: 330, width: 160 },
                { x: 3550, y: 390, width: 150 },
                { x: 3850, y: 350, width: 140 },
                { x: 4150, y: 380, width: 150 }
            ],
            coins: [
                { x: 375, y: 380 }, { x: 625, y: 340 }, { x: 870, y: 300 },
                { x: 1125, y: 320 }, { x: 1425, y: 360 }, { x: 1720, y: 320 },
                { x: 2025, y: 280 }, { x: 2325, y: 340 }, { x: 2675, y: 300 },
                { x: 2975, y: 340 }, { x: 3280, y: 290 }, { x: 3630, y: 350 },
                { x: 3930, y: 310 }, { x: 4230, y: 350 }, { x: 5000, y: 550 }
            ],
            obstacles: [
                { x: 480, y: 260, startX: 480 },
                { x: 1050, y: 270, startX: 1050 },
                { x: 1700, y: 265, startX: 1700 },
                { x: 2400, y: 275, startX: 2400 },
                { x: 3100, y: 280, startX: 3100 },
                { x: 3850, y: 270, startX: 3850 },
                { x: 4550, y: 275, startX: 4550 }
            ]
        },
        5: {
            name: "Maestro Supremo",
            length: 6000,
            floorSegments: [
                { x: 0, width: 350 },
                { x: 550, width: 280 },
                { x: 1000, width: 300 },
                { x: 1500, width: 280 },
                { x: 2000, width: 320 },
                { x: 2550, width: 280 },
                { x: 3100, width: 300 },
                { x: 3650, width: 280 },
                { x: 4200, width: 300 }
            ],
            platforms: [
                { x: 250, y: 420, width: 130 },
                { x: 500, y: 380, width: 120 },
                { x: 750, y: 340, width: 130 },
                { x: 1000, y: 380, width: 120 },
                { x: 1250, y: 320, width: 130 },
                { x: 1500, y: 280, width: 120 },
                { x: 1750, y: 400, width: 140 },
                { x: 2050, y: 350, width: 130 },
                { x: 2300, y: 300, width: 120 },
                { x: 2600, y: 250, width: 130 },
                { x: 2900, y: 380, width: 140 },
                { x: 3200, y: 330, width: 130 },
                { x: 3500, y: 370, width: 120 },
                { x: 3800, y: 310, width: 130 },
                { x: 4100, y: 270, width: 120 },
                { x: 4400, y: 400, width: 140 },
                { x: 4700, y: 350, width: 130 }
            ],
            coins: [
                { x: 315, y: 380 }, { x: 565, y: 340 }, { x: 820, y: 300 },
                { x: 1070, y: 340 }, { x: 1320, y: 280 }, { x: 1570, y: 240 },
                { x: 1840, y: 360 }, { x: 2135, y: 310 }, { x: 2385, y: 260 },
                { x: 2685, y: 210 }, { x: 2985, y: 340 }, { x: 3285, y: 290 },
                { x: 3585, y: 330 }, { x: 3885, y: 270 }, { x: 4185, y: 230 },
                { x: 4485, y: 360 }, { x: 4785, y: 310 }, { x: 5850, y: 550 }
            ],
            obstacles: [
                { x: 450, y: 260, startX: 450 },
                { x: 1000, y: 270, startX: 1000 },
                { x: 1600, y: 265, startX: 1600 },
                { x: 2250, y: 275, startX: 2250 },
                { x: 2900, y: 280, startX: 2900 },
                { x: 3500, y: 270, startX: 3500 },
                { x: 4200, y: 275, startX: 4200 },
                { x: 4950, y: 280, startX: 4950 },
                { x: 5600, y: 270, startX: 5600 }
            ]
        }
    };

    /**
     * Validates level design to ensure playability requirements are met.
     * 
     * @param {Object} levelData - A level object from LEVELS
     * @param {string} levelData.name - Level name
     * @param {number} levelData.length - Total level length
     * @param {Array} levelData.floorSegments - Array of {x, width} objects
     * @param {Array} levelData.platforms - Array of {x, y, width} objects
     * @param {Array} levelData.coins - Array of {x, y} objects
     * @param {Array} levelData.obstacles - Array of {x, y, startX} objects
     * 
     * Checks:
     * - Floor segment gaps are ‚â§280px (max jump distance with safety margin)
     * - Platform horizontal gaps are ‚â§180px
     * - Platform vertical spacing is reasonable (100-140px)
     * - Coins are within reachable bounds
     * - Obstacles are positioned at y>250px
     * 
     * Logs warnings to console for any violations.
     */
    function validateLevel(levelData) {
        const MAX_FLOOR_GAP = 280; // Max jump distance with safety margin
        const MAX_PLATFORM_GAP = 180;
        const MIN_VERTICAL_SPACING = 100;
        const MAX_VERTICAL_SPACING = 140;
        const MIN_OBSTACLE_Y = 250;
        const GROUND_Y = 550; // Ground level
        
        let hasWarnings = false;
        const levelName = levelData.name || 'Unknown';
        
        // Validate floor segment gaps
        if (levelData.floorSegments && levelData.floorSegments.length > 1) {
            for (let i = 0; i < levelData.floorSegments.length - 1; i++) {
                const current = levelData.floorSegments[i];
                const next = levelData.floorSegments[i + 1];
                const currentEnd = current.x + current.width;
                const gap = next.x - currentEnd;
                
                if (gap > MAX_FLOOR_GAP) {
                    console.warn(`[${levelName}] Floor gap ${i}-${i+1} is ${gap}px (max: ${MAX_FLOOR_GAP}px)`);
                    hasWarnings = true;
                }
            }
        }
        
        // Validate platform gaps and spacing
        if (levelData.platforms && levelData.platforms.length > 1) {
            const sortedPlatforms = [...levelData.platforms].sort((a, b) => a.x - b.x);
            
            for (let i = 0; i < sortedPlatforms.length - 1; i++) {
                const current = sortedPlatforms[i];
                const next = sortedPlatforms[i + 1];
                const currentEnd = current.x + current.width;
                const horizontalGap = next.x - currentEnd;
                const verticalSpacing = Math.abs(next.y - current.y);
                
                if (horizontalGap > MAX_PLATFORM_GAP) {
                    console.warn(`[${levelName}] Platform gap ${i}-${i+1} is ${horizontalGap}px (max: ${MAX_PLATFORM_GAP}px)`);
                    hasWarnings = true;
                }
                
                if (verticalSpacing < MIN_VERTICAL_SPACING || verticalSpacing > MAX_VERTICAL_SPACING) {
                    if (horizontalGap < MAX_PLATFORM_GAP) { // Only warn if platforms are close horizontally
                        console.warn(`[${levelName}] Platform vertical spacing ${i}-${i+1} is ${verticalSpacing}px (recommended: ${MIN_VERTICAL_SPACING}-${MAX_VERTICAL_SPACING}px)`);
                        hasWarnings = true;
                    }
                }
            }
        }
        
        // Validate coin accessibility (basic bounds check)
        if (levelData.coins) {
            levelData.coins.forEach((coin, index) => {
                if (coin.y < 0 || coin.y > GROUND_Y + 100) {
                    console.warn(`[${levelName}] Coin ${index} at (${coin.x}, ${coin.y}) may be out of reachable bounds`);
                    hasWarnings = true;
                }
            });
        }
        
        // Validate obstacle positions
        if (levelData.obstacles) {
            levelData.obstacles.forEach((obstacle, index) => {
                if (obstacle.y < MIN_OBSTACLE_Y) {
                    console.warn(`[${levelName}] Obstacle ${index} at y=${obstacle.y} is below recommended minimum (${MIN_OBSTACLE_Y}px)`);
                    hasWarnings = true;
                }
            });
        }
        
        if (!hasWarnings) {
            console.log(`[${levelName}] Level validation passed ‚úì`);
        }
        
        return !hasWarnings;
    }

    // ==========================================================================
    // DOM UTILITIES
    // ==========================================================================
    
    const DOM = {
        get: (id) => document.getElementById(id),
        
        elements: {},
        
        init() {
            this.elements = {
                startScreen: this.get('startScreen'),
                gameContainer: this.get('gameContainer'),
                countdownOverlay: this.get('countdownOverlay'),
                countdownNumber: this.get('countdownNumber'),
                resultsScreen: this.get('resultsScreen'),
                winnerSection: this.get('winnerSection'),
                resultsBody: this.get('resultsBody'),
                adminHint: this.get('adminHint'),
                levelSelector: this.get('levelSelector'),
                levelName: this.get('levelName'),
                nextLevelBtn: this.get('nextLevelBtn'),
                levelSelectBtn: this.get('levelSelectBtn'),
                waitingAdmin: this.get('waitingAdmin'),
                confettiContainer: this.get('confettiContainer')
            };
        }
    };

    // ==========================================================================
    // AUDIO MANAGER
    // ==========================================================================
    
    const AudioManager = {
        context: null,
        
        init() {
            if (!this.context) {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
            }
        },
        
        play(type) {
            this.init();
            const ctx = this.context;
            const t = ctx.currentTime;
            
            const sounds = {
                jump: () => this._playTone(400, 800, 0.1, 0.1),
                coin: () => this._playArpeggio([1000, 1250, 1500], 0.08, 0.05),
                hit: () => this._playSawtooth(200, 80, 0.15, 0.12),
                win: () => this._playArpeggio([523, 659, 784, 1047], 0.1, 0.12),
                count: () => this._playTone(500, 500, 0.12, 0.1),
                go: () => this._playArpeggio([600, 900, 1200], 0.12, 0.04)
            };
            
            if (sounds[type]) sounds[type]();
        },
        
        _playTone(startFreq, endFreq, duration, gain) {
            const ctx = this.context;
            const t = ctx.currentTime;
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            
            o.connect(g);
            g.connect(ctx.destination);
            o.frequency.setValueAtTime(startFreq, t);
            o.frequency.exponentialRampToValueAtTime(endFreq, t + duration);
            g.gain.setValueAtTime(gain, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + duration);
            o.start(t);
            o.stop(t + duration);
        },
        
        _playArpeggio(frequencies, gain, delay) {
            const ctx = this.context;
            const t = ctx.currentTime;
            
            frequencies.forEach((f, i) => {
                const osc = ctx.createOscillator();
                const gainNode = ctx.createGain();
                osc.connect(gainNode);
                gainNode.connect(ctx.destination);
                osc.frequency.value = f;
                gainNode.gain.setValueAtTime(gain, t + i * delay);
                gainNode.gain.exponentialRampToValueAtTime(0.001, t + i * delay + 0.15);
                osc.start(t + i * delay);
                osc.stop(t + i * delay + 0.15);
            });
        },
        
        _playSawtooth(startFreq, endFreq, duration, gain) {
            const ctx = this.context;
            const t = ctx.currentTime;
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            
            o.type = 'sawtooth';
            o.connect(g);
            g.connect(ctx.destination);
            o.frequency.setValueAtTime(startFreq, t);
            o.frequency.exponentialRampToValueAtTime(endFreq, t + duration);
            g.gain.setValueAtTime(gain, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + duration);
            o.start(t);
            o.stop(t + duration);
        }
    };

    // ==========================================================================
    // EFFECTS MANAGER
    // ==========================================================================
    
    const EffectsManager = {
        spawnConfetti() {
            const container = DOM.elements.confettiContainer;
            container.innerHTML = '';
            
            for (let i = 0; i < CONFIG.CONFETTI_COUNT; i++) {
                const el = document.createElement('div');
                el.className = 'confetti';
                const color = CONFIG.CONFETTI_COLORS[Math.floor(Math.random() * CONFIG.CONFETTI_COLORS.length)];
                el.style.cssText = `
                    left: ${Math.random() * 100}%;
                    top: -20px;
                    width: ${8 + Math.random() * 8}px;
                    height: ${8 + Math.random() * 8}px;
                    background: ${color};
                    border-radius: ${Math.random() > 0.5 ? '50%' : '2px'};
                    animation-delay: ${Math.random() * 2}s;
                    animation-duration: ${2 + Math.random() * 2}s;
                `;
                container.appendChild(el);
            }
            
            setTimeout(() => container.innerHTML = '', 5000);
        }
    };

    // ==========================================================================
    // UI MANAGER
    // ==========================================================================
    
    const UIManager = {
        async countdown() {
            const overlay = DOM.elements.countdownOverlay;
            const num = DOM.elements.countdownNumber;
            overlay.classList.remove('hidden');
            
            const steps = [
                ['3', '#EB8225'],
                ['2', '#AB3D8B'],
                ['1', '#0595AE'],
                ['GO!', '#73A03F']
            ];
            
            for (const [val, color] of steps) {
                num.textContent = val;
                num.style.color = color;
                num.style.animation = 'none';
                num.offsetHeight; // Force reflow
                num.style.animation = 'countPop 0.6s ease-out';
                AudioManager.play(val === 'GO!' ? 'go' : 'count');
                await new Promise(r => setTimeout(r, 750));
            }
            
            overlay.classList.add('hidden');
        },
        
        updatePlayerSlots(players, admin) {
            const count = Object.keys(players).length;
            
            for (let i = 1; i <= CONFIG.MAX_PLAYERS; i++) {
                const slot = DOM.get(`playerSlot${i}`);
                const player = players[i];
                
                slot.className = 'player-card';
                
                if (player) {
                    slot.classList.add(player.isAdmin ? 'admin' : 'ready');
                    slot.innerHTML = this._renderPlayerSlot(player);
                } else {
                    slot.innerHTML = this._renderEmptySlot(i);
                }
            }
            
            DOM.elements.adminHint.classList.toggle('hidden', count === 0);
            DOM.elements.levelSelector.classList.toggle('hidden', count === 0);
        },
        
        _renderPlayerSlot(player) {
            return `
                <div class="text-lg sm:text-xl font-bold flex items-center justify-center gap-2" style="color:${player.color}">
                    ${player.isAdmin ? '<iconify-icon icon="mdi:crown" class="text-steam-naranja text-2xl"></iconify-icon>' : '<iconify-icon icon="mdi:account-check" class="text-xl"></iconify-icon>'}
                    ${player.name}
                </div>
                <div class="flex justify-center my-3 float">
                    <div class="player-avatar" style="background:${player.color}"></div>
                </div>
                <div class="text-sm font-bold flex items-center justify-center gap-1 ${player.disconnected ? 'text-steam-morado' : 'text-steam-verde'}">
                    ${player.disconnected 
                        ? '<iconify-icon icon="mdi:wifi-off"></iconify-icon> Desconectado' 
                        : '<iconify-icon icon="mdi:check-circle"></iconify-icon> Listo!'}
                </div>
            `;
        },
        
        _renderEmptySlot(slotNum) {
            return `
                <div class="text-lg sm:text-xl font-bold text-gray-400 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador ${slotNum}
                </div>
                <div class="flex justify-center my-3 float">
                    <div class="player-avatar bg-gray-200"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            `;
        },
        
        showResults(results, levelCompleted, hasNextLevel) {
            const winnerDiv = DOM.elements.winnerSection;
            
            if (results.length) {
                const winner = results[0];
                winnerDiv.innerHTML = `
                    <iconify-icon icon="mdi:trophy" class="text-6xl text-steam-naranja mb-4"></iconify-icon>
                    <div class="player-avatar mx-auto mb-4" style="background:${winner.color};width:100px;height:100px;border-radius:20px;box-shadow:0 0 30px ${winner.color}50"></div>
                    <div class="text-2xl font-black" style="color:${winner.color}">${winner.name}</div>
                    <div class="text-xl text-steam-verde font-bold mt-2 flex items-center justify-center gap-2">
                        <iconify-icon icon="mdi:star"></iconify-icon>
                        ${winner.score} pts
                    </div>
                `;
                AudioManager.play('win');
                EffectsManager.spawnConfetti();
            }
            
            this._renderResultsTable(results);
            this._updateResultButtons(levelCompleted, hasNextLevel);
            
            DOM.elements.resultsScreen.style.display = 'flex';
        },
        
        _renderResultsTable(results) {
            const tbody = DOM.elements.resultsBody;
            tbody.innerHTML = '';
            
            const medals = ['mdi:medal-outline', 'mdi:medal-outline', 'mdi:medal-outline'];
            const medalColors = ['#FFD700', '#C0C0C0', '#CD7F32'];
            
            results.forEach((r, i) => {
                const row = document.createElement('tr');
                row.className = i === 0 ? 'bg-amber-50' : i % 2 ? 'bg-gray-50' : '';
                row.innerHTML = `
                    <td class="py-3 px-2 text-xl">
                        ${i < 3 
                            ? `<iconify-icon icon="${medals[i]}" style="color:${medalColors[i]}" class="text-2xl"></iconify-icon>` 
                            : `#${i+1}`}
                    </td>
                    <td class="py-3 px-2">
                        <div class="flex items-center gap-2">
                            <div class="w-6 h-6 rounded-md relative" style="background:${r.color}">
                                <span class="absolute top-1 left-1 w-1.5 h-1.5 bg-white rounded-full"></span>
                                <span class="absolute top-1 right-1 w-1.5 h-1.5 bg-white rounded-full"></span>
                            </div>
                            <span class="font-bold">${r.name}</span>
                        </div>
                    </td>
                    <td class="py-3 px-2 text-center text-steam-naranja font-bold">${r.coins}</td>
                    <td class="py-3 px-2 text-center">${r.time}s</td>
                    <td class="py-3 px-2 text-right font-black text-steam-verde">${r.score}</td>
                `;
                tbody.appendChild(row);
            });
        },
        
        _updateResultButtons(levelCompleted, hasNextLevel) {
            if (levelCompleted && hasNextLevel) {
                DOM.elements.nextLevelBtn.classList.remove('hidden');
            } else {
                DOM.elements.nextLevelBtn.classList.add('hidden');
            }
            
            DOM.elements.levelSelectBtn.classList.remove('hidden');
            DOM.elements.waitingAdmin.classList.add('hidden');
        }
    };

    // ==========================================================================
    // LEVEL MANAGER
    // ==========================================================================
    
    const LevelManager = {
        progress: {
            currentLevel: 1,
            unlockedLevels: [1],
            completedLevels: []
        },
        
        init() {
            this.setupButtons();
        },
        
        setupButtons() {
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const level = parseInt(btn.dataset.level);
                    if (this.progress.unlockedLevels.includes(level)) {
                        this.selectLevel(level);
                    }
                });
            });
        },
        
        selectLevel(level) {
            this.progress.currentLevel = level;
            this.updateButtons();
            DOM.elements.levelName.textContent = LEVELS[level].name;
            GameManager.airconsole.broadcast({ action: 'levelChanged', level, name: LEVELS[level].name });
        },
        
        updateButtons() {
            document.querySelectorAll('.level-btn').forEach(btn => {
                const btnLevel = parseInt(btn.dataset.level);
                const isUnlocked = this.progress.unlockedLevels.includes(btnLevel);
                const isSelected = btnLevel === this.progress.currentLevel;
                const isCompleted = this.progress.completedLevels.includes(btnLevel);
                
                if (isSelected) {
                    btn.className = 'level-btn bg-steam-verde text-white font-bold py-2 px-4 rounded-xl border-2 border-steam-verde';
                    btn.disabled = false;
                } else if (isCompleted) {
                    btn.className = 'level-btn bg-steam-turquesa text-white font-bold py-2 px-4 rounded-xl border-2 border-steam-turquesa';
                    btn.disabled = false;
                } else if (isUnlocked) {
                    btn.className = 'level-btn bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-xl border-2 border-gray-300';
                    btn.disabled = false;
                } else {
                    btn.className = 'level-btn bg-gray-100 text-gray-400 font-bold py-2 px-4 rounded-xl border-2 border-gray-200 opacity-50 cursor-not-allowed';
                    btn.disabled = true;
                }
            });
        },
        
        completeLevel(level) {
            if (!this.progress.completedLevels.includes(level)) {
                this.progress.completedLevels.push(level);
            }
            
            const nextLevel = level + 1;
            if (nextLevel <= 5 && !this.progress.unlockedLevels.includes(nextLevel)) {
                this.progress.unlockedLevels.push(nextLevel);
            }
        },
        
        getLevelData() {
            return LEVELS[this.progress.currentLevel];
        },
        
        hasNextLevel() {
            return this.progress.currentLevel < 5;
        }
    };

    // ==========================================================================
    // GAME CLASS
    // ==========================================================================
    
    class Game {
        constructor(playerNum, color, name) {
            this.num = playerNum;
            this.color = color;
            this.name = name;
            
            // Canvas
            this.canvas = null;
            this.ctx = null;
            
            // Input
            this.keys = { left: false, right: false, jump: false };
            
            // State
            this.finishTime = null;
            this.resultsShown = false;
            this.running = false;
            this.animationFrameId = null;
            this.lastFrameTime = 0;
            
            // Player physics
            this.player = { x: 80, y: 300, vx: 0, vy: 0, w: 44, h: 44, facing: 1, stunned: 0 };
            this.coins = 0;
            this.won = false;
            this.grounded = false;
            this.camX = 0;
            this.lookAheadOffset = 0;
            this.coyoteCounter = 0;
            this.jumpBufferCounter = 0;
            
            // Visual effects
            this.particles = [];
            this.trail = [];
            
            // Load theme based on current level
            const currentLevel = LevelManager.progress.currentLevel;
            this.theme = LEVEL_THEMES[currentLevel] || LEVEL_THEMES[1];
            
            // Level data (cloned from level manager)
            const levelData = LevelManager.getLevelData();
            this.floors = levelData.floorSegments.map(f => ({...f}));
            this.platforms = levelData.platforms.map((p, i) => ({
                ...p, 
                h: 16,
                startX: p.x,
                dir: i % 2 === 0 ? 1 : -1,
                speed: 1 + Math.random() * 0.5,
                range: 60 + Math.random() * 40
            }));
            this.coinList = levelData.coins.map(c => ({...c, got: false, bob: Math.random() * 6.28}));
            this.obstacles = levelData.obstacles.map(o => ({
                ...o, 
                w: 48, 
                h: 48, 
                dir: 1, 
                spd: 2 + Math.random(), 
                range: 100 + Math.random() * 50,
                bitePhase: Math.random() * Math.PI * 2, // Fase de animaci√≥n de mordedura
                biteSpeed: 0.15 + Math.random() * 0.1,  // Velocidad de mordedura
                lastBiteTime: 0                          // Tiempo de √∫ltima mordedura
            }));
            this.finishX = levelData.length - 200;
        }

        init() {
            this.canvas = DOM.get(`canvas${this.num}`);
            this.ctx = this.canvas.getContext('2d', { alpha: false });
            
            const container = DOM.get(`screen${this.num}`);
            this.canvas.width = container.clientWidth;
            this.canvas.height = container.clientHeight;
            
            const ratio = this.canvas.height / 700;
            this.floorY = this.canvas.height - 70;
            
            // Scale level elements
            this.floors.forEach(f => f.y = this.floorY);
            this.platforms.forEach(p => p.y *= ratio);
            this.coinList.forEach(c => c.y *= ratio);
            this.obstacles.forEach(o => o.y *= ratio);
            this.player.y = 300 * ratio;
            
            // Cache DOM elements
            this.coinsEl = DOM.get(`coins${this.num}`);
            this.progressEl = DOM.get(`progress${this.num}`);
            
            this.running = true;
            this.loop();
        }

        update() {
            if (!GameManager.state.started) return;
            
            const p = this.player;
            const prevY = p.y;
            
            this._updatePlatforms();
            
            if (!this.won) {
                this._updateMovement(p);
                this._updatePhysics(p, prevY);
                this._updateObstacles(p);
                this._updateCoins(p);
            } else {
                this._playVictoryAnimation(p);
            }
            
            this._updateParticles();
            this._checkFinish(p);
        }
        
        _updatePlatforms() {
            this.platforms.forEach(pl => {
                pl.x += pl.dir * pl.speed;
                if (Math.abs(pl.x - pl.startX) > pl.range) {
                    pl.dir *= -1;
                }
            });
        }

        _updateMovement(p) {
            if (!p.stunned) {
                const targetVx = this.keys.left ? -PHYSICS.MOVE_SPEED : 
                                 this.keys.right ? PHYSICS.MOVE_SPEED : 0;
                const acceleration = this.grounded ? PHYSICS.GROUND_ACCELERATION : PHYSICS.AIR_ACCELERATION;
                
                if (targetVx !== 0) {
                    p.vx += (targetVx - p.vx) * acceleration;
                    p.facing = targetVx > 0 ? 1 : -1;
                } else if (this.grounded) {
                    p.vx *= PHYSICS.FRICTION;
                    if (Math.abs(p.vx) < 0.1) p.vx = 0;
                }
            } else {
                p.vx *= PHYSICS.AIR_RESISTANCE;
            }
            
            if (p.stunned > 0) p.stunned--;
            
            // Trail effect
            if (Math.abs(p.vx) > 1 || Math.abs(p.vy) > 3) {
                this.trail.push({ x: p.x, y: p.y, a: 0.4 });
                if (this.trail.length > 4) this.trail.shift();
            }
            
            for (let i = this.trail.length - 1; i >= 0; i--) {
                this.trail[i].a *= 0.85;
                if (this.trail[i].a <= 0.05) this.trail.splice(i, 1);
            }
        }

        _updatePhysics(p, prevY) {
            // Jump buffering logic
            if (this.keys.jump && !p.stunned) {
                this.jumpBufferCounter = PHYSICS.JUMP_BUFFER;
            } else if (this.jumpBufferCounter > 0) {
                this.jumpBufferCounter--;
            }
            
            // Gravity
            p.vy += PHYSICS.GRAVITY;
            if (p.vy > PHYSICS.MAX_FALL_SPEED) p.vy = PHYSICS.MAX_FALL_SPEED;
            
            // Apply movement
            p.x += p.vx;
            p.y += p.vy;
            
            // Collisions
            this.grounded = false;
            
            // Floor collision
            this.floors.forEach(f => {
                if (p.x + p.w > f.x + 2 && p.x < f.x + f.width - 2) {
                    if (p.vy >= 0 && prevY + p.h <= f.y + 8 && p.y + p.h >= f.y) {
                        p.y = f.y - p.h;
                        p.vy = 0;
                        this.grounded = true;
                    }
                }
            });
            
            // Platform collision
            this.platforms.forEach(pl => {
                if (p.x + p.w > pl.x + 2 && p.x < pl.x + pl.width - 2) {
                    if (p.vy >= 0 && prevY + p.h <= pl.y + 8 && p.y + p.h >= pl.y && p.y < pl.y + pl.h) {
                        p.y = pl.y - p.h;
                        p.vy = 0;
                        this.grounded = true;
                    }
                }
            });
            
            // Coyote time tracking
            if (this.grounded) {
                this.coyoteCounter = PHYSICS.COYOTE_TIME;
            } else if (this.coyoteCounter > 0) {
                this.coyoteCounter--;
            }
            
            // Jump execution with buffering and coyote time
            const canJump = (this.grounded || this.coyoteCounter > 0) && !p.stunned;
            if (this.jumpBufferCounter > 0 && canJump) {
                p.vy = PHYSICS.JUMP_POWER;
                AudioManager.play('jump');
                this.grounded = false;
                this.coyoteCounter = 0;
                this.jumpBufferCounter = 0;
                // Aumentar cantidad de part√≠culas de burst de 5 a 12
                this._burst(p.x + p.w/2, p.y + p.h, '#8BC34A', 12);
                // Agregar part√≠cula tipo 'ring' con propiedades especificadas
                const maxParticles = 150;
                if (this.particles.length < maxParticles) {
                    this.particles.push({
                        x: p.x + p.w/2,
                        y: p.y + p.h,
                        vx: 0,
                        vy: 0,
                        life: 20,
                        color: 'rgba(115, 160, 63, 0.5)',
                        type: 'ring',
                        radius: 10
                    });
                }
            }
            
            // Variable jump height (jump cut)
            if (!this.keys.jump && p.vy < PHYSICS.JUMP_CUT_THRESHOLD) {
                p.vy *= PHYSICS.JUMP_CUT_MULTIPLIER;
            }
            
            // Fall death
            if (p.y > this.canvas.height + 50) {
                this._burst(p.x + p.w/2, this.canvas.height - 50, '#AB3D8B', 12);
                p.x = 80;
                p.y = 300 * (this.canvas.height / 700);
                p.vx = p.vy = 0;
                AudioManager.play('hit');
            }
            
            // Bounds
            p.x = Math.max(0, p.x);
            
            // Camera
            this._updateCamera(p);
            
            // Progress
            if (this.progressEl) {
                this.progressEl.style.width = Math.min(100, p.x / this.finishX * 100) + '%';
            }
        }

        _updateCamera(p) {
            // Calcular offset de look-ahead: p.facing * 100 p√≠xeles en direcci√≥n del movimiento
            const targetLookAhead = p.facing * 100;
            
            // Aplicar suavizado exponencial con factor 0.1 para transiciones fluidas
            this.lookAheadOffset += (targetLookAhead - this.lookAheadOffset) * 0.1;
            
            // Calcular posici√≥n base de c√°mara
            let targetCamX = p.x - this.canvas.width / 2 + this.lookAheadOffset;
            
            // Agregar efecto de shake cuando p.stunned > 0 usando valores aleatorios de ¬±4 p√≠xeles
            if (p.stunned > 0) {
                targetCamX += (Math.random() - 0.5) * 8;
            }
            
            // Mantener l√≠mites existentes (0 hasta finishX - canvas.width + 150)
            this.camX = Math.max(0, Math.min(targetCamX, this.finishX - this.canvas.width + 150));
        }

        _updateObstacles(p) {
            const now = performance.now();
            
            this.obstacles.forEach(o => {
                o.x += o.dir * o.spd;
                if (Math.abs(o.x - o.startX) > o.range) o.dir *= -1;
                
                // Animaci√≥n de mordedura continua
                o.bitePhase += o.biteSpeed;
                
                // Mordedura agresiva cuando el jugador est√° cerca
                const distToPlayer = Math.abs((o.x + o.w/2) - (p.x + p.w/2));
                if (distToPlayer < 150) {
                    o.biteSpeed = 0.25; // Morder m√°s r√°pido
                } else {
                    o.biteSpeed = 0.15; // Velocidad normal
                }
                
                // Culling
                if (Math.abs(o.x - p.x) > 200) return;
                
                // Collision
                const margin = 2;
                if (!p.stunned && 
                    p.x + p.w - margin > o.x && 
                    p.x + margin < o.x + o.w && 
                    p.y + p.h - margin > o.y && 
                    p.y + margin < o.y + o.h) {
                    p.stunned = 45;
                    AudioManager.play('hit');
                    this._burst(p.x + p.w/2, p.y + p.h/2, '#333', 8);
                    p.vy = -8;
                    p.vx = o.dir * -4;
                    // Activar mordedura en colisi√≥n
                    o.lastBiteTime = now;
                }
            });
        }

        _updateCoins(p) {
            this.coinList.forEach(c => {
                if (c.got) return;
                if (Math.abs(c.x - p.x) > 100) return;
                
                const dx = (p.x + p.w/2) - c.x;
                const dy = (p.y + p.h/2) - c.y;
                const distSq = dx * dx + dy * dy;
                
                if (distSq < 900) {
                    c.got = true;
                    this.coins++;
                    if (this.coinsEl) this.coinsEl.textContent = this.coins;
                    this._burst(c.x, c.y, '#EB8225', 8);
                    AudioManager.play('coin');
                    // Agregar part√≠cula tipo 'text' con propiedades especificadas
                    const maxParticles = 150;
                    if (this.particles.length < maxParticles) {
                        this.particles.push({
                            x: c.x,
                            y: c.y,
                            vx: 0,
                            vy: -2,
                            life: 30,
                            color: '#FFD700',
                            type: 'text',
                            text: '+1'
                        });
                    }
                }
            });
        }

        _updateParticles() {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const pt = this.particles[i];
                pt.x += pt.vx;
                pt.y += pt.vy;
                pt.vy += 0.15;
                pt.life--;
                if (pt.life <= 0) this.particles.splice(i, 1);
            }
        }

        _checkFinish(p) {
            if (p.x > this.finishX && !this.won) {
                this.won = true;
                this.finishTime = Date.now();
                this._burst(p.x + p.w/2, p.y, '#73A03F', 20);
                
                // Count finished players
                const finishedCount = Object.values(GameManager.state.games).filter(
                    g => g.won && !GameManager.state.players[g.num].disconnected
                ).length;
                
                // Show overlay on first finish
                if (finishedCount === 1) {
                    GameManager.showLiveRankingOverlay(this.num);
                }
                
                // Always update ranking when someone finishes
                GameManager.updateLiveRanking();
                
                // Check if all players finished
                const allDone = Object.values(GameManager.state.games).every(
                    g => g.won || GameManager.state.players[g.num].disconnected
                );
                
                if (allDone && !GameManager.state.resultsDisplayed) {
                    GameManager.state.resultsDisplayed = true;
                    setTimeout(() => {
                        GameManager.hideLiveRankingOverlay();
                        GameManager.showResults();
                    }, 2000);
                }
            }
        }

        _playVictoryAnimation(p) {
            // Bounce in place using sine wave
            p.y += Math.sin(Date.now() / 200) * 2;
            p.facing = 1;
            
            // Periodic celebratory particle bursts
            if (Math.random() < 0.05) {
                this._burst(p.x + p.w/2, p.y, this.color, 8);
            }
        }

        draw() {
            const ctx = this.ctx;
            const w = this.canvas.width;
            const h = this.canvas.height;
            
            this._drawBackground(ctx, w, h);
            
            ctx.save();
            ctx.translate(-this.camX, 0);
            
            this._drawClouds(ctx, w);
            this._drawFloors(ctx, w);
            this._drawDecorations(ctx, w);
            this._drawPlatforms(ctx, w);
            this._drawObstacles(ctx, w);
            this._drawCoins(ctx, w);
            this._drawFinish(ctx);
            this._drawParticles(ctx);
            this._drawTrail(ctx);
            this._drawPlayer(ctx);
            
            ctx.restore();
            
            // Indicadores fuera de pantalla
            this._drawOffScreenIndicators(ctx, w, h);
        }

        _drawOffScreenIndicators(ctx, w, h) {
            this.coinList.forEach(c => {
                if (c.got) return;
                
                // Verificar si moneda est√° fuera de pantalla comparando c.x con this.camX y this.camX + w
                const isOffScreenLeft = c.x < this.camX;
                const isOffScreenRight = c.x > this.camX + w;
                
                if (!isOffScreenLeft && !isOffScreenRight) return;
                
                // Dibujar flecha triangular en borde de pantalla (x=20 o x=w-20, y=50)
                const arrowX = isOffScreenLeft ? 20 : w - 20;
                const arrowY = 50;
                
                // Usar color naranja #EB8225 para consistencia visual
                ctx.fillStyle = '#EB8225';
                ctx.beginPath();
                if (isOffScreenLeft) {
                    // Flecha apuntando a la derecha
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX + 10, arrowY - 5);
                    ctx.lineTo(arrowX + 10, arrowY + 5);
                } else {
                    // Flecha apuntando a la izquierda
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX - 10, arrowY - 5);
                    ctx.lineTo(arrowX - 10, arrowY + 5);
                }
                ctx.closePath();
                ctx.fill();
                
                // Mostrar distancia en metros usando Math.floor(Math.abs(c.x - this.player.x))
                const distance = Math.floor(Math.abs(c.x - this.player.x));
                ctx.fillStyle = '#EB8225';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(distance + 'm', arrowX, arrowY + 10);
            });
        }

        _drawBackground(ctx, w, h) {
            const gradient = ctx.createLinearGradient(0, 0, 0, h);
            gradient.addColorStop(0, this.theme.sky[0]);
            gradient.addColorStop(0.5, this.theme.sky[1]);
            gradient.addColorStop(1, this.theme.sky[2]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, w, h);
        }

        _drawClouds(ctx, w) {
            ctx.fillStyle = this.theme.clouds;
            const parallaxOffset = this.camX * 0.3;
            const clouds = [
                [100, 60], [400, 90], [800, 50], [1200, 80], [1700, 65], 
                [2200, 75], [2700, 55], [3200, 70], [3700, 85], [4200, 60],
                [4700, 75], [5200, 65], [5700, 80]
            ];
            clouds.forEach(([x, y]) => {
                const cloudX = x - parallaxOffset;
                if (cloudX < this.camX - 100 || cloudX > this.camX + w + 100) return;
                ctx.beginPath();
                ctx.arc(cloudX, y, 30, 0, Math.PI * 2);
                ctx.arc(cloudX + 25, y - 5, 22, 0, Math.PI * 2);
                ctx.arc(cloudX + 50, y, 28, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        _drawFloors(ctx, w) {
            this.floors.forEach(f => {
                if (f.x + f.width < this.camX || f.x > this.camX + w) return;
                
                ctx.fillStyle = this.theme.floor[0];
                ctx.fillRect(f.x, f.y, f.width, 70);
                ctx.fillStyle = this.theme.floor[1];
                ctx.fillRect(f.x, f.y, f.width, 12);
                ctx.fillStyle = this.theme.accent;
                for (let gx = f.x + 10; gx < f.x + f.width - 10; gx += 25) {
                    ctx.fillRect(gx, f.y - 4, 3, 8);
                }
            });
        }

        _drawPlatforms(ctx, w) {
            this.platforms.forEach(pl => {
                if (pl.x + pl.width < this.camX || pl.x > this.camX + w) return;
                
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(pl.x + 4, pl.y + pl.h, pl.width, 4);
                
                // Platform gradient
                const gradient = ctx.createLinearGradient(pl.x, pl.y, pl.x, pl.y + pl.h);
                gradient.addColorStop(0, this.theme.platform[1]);
                gradient.addColorStop(1, this.theme.platform[0]);
                ctx.fillStyle = gradient;
                ctx.fillRect(pl.x, pl.y, pl.width, pl.h);
                
                // Agregar l√≠neas verticales cada 20px con fillStyle = 'rgba(255, 255, 255, 0.1)'
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                for (let x = pl.x; x < pl.x + pl.width; x += 20) {
                    ctx.fillRect(x, pl.y, 1, pl.h);
                }
                
                // Para plataformas m√≥viles (pl.speed > 0), dibujar indicador dorado en la parte superior centrada (20px de ancho, 2px de alto)
                if (pl.speed > 0) {
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(pl.x + pl.width / 2 - 10, pl.y, 20, 2);
                }
                
                // Top border
                ctx.fillStyle = this.theme.accent;
                ctx.fillRect(pl.x, pl.y, pl.width, 3);
            });
        }

        _drawDecorations(ctx, w) {
            switch (this.theme.decorations) {
                case 'flowers':
                    this._drawFlowers(ctx, w);
                    break;
                case 'cacti':
                    this._drawCacti(ctx, w);
                    break;
                case 'snow':
                    this._drawSnow(ctx, w);
                    break;
                case 'lava':
                    this._drawLava(ctx, w);
                    break;
                case 'stars':
                    this._drawStars(ctx, w);
                    break;
            }
        }

        _drawFlowers(ctx, w) {
            this.floors.forEach(f => {
                if (f.x + f.width < this.camX || f.x > this.camX + w) return;
                
                for (let x = f.x + 40; x < f.x + f.width - 40; x += 80) {
                    if (x < this.camX - 20 || x > this.camX + w + 20) continue;
                    
                    // Stem
                    ctx.fillStyle = '#73A03F';
                    ctx.fillRect(x - 1, f.y - 15, 2, 15);
                    
                    // Flower head
                    ctx.fillStyle = '#FF69B4';
                    ctx.beginPath();
                    ctx.arc(x, f.y - 15, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        _drawCacti(ctx, w) {
            this.floors.forEach(f => {
                if (f.x + f.width < this.camX || f.x > this.camX + w) return;
                
                for (let x = f.x + 60; x < f.x + f.width - 60; x += 120) {
                    if (x < this.camX - 30 || x > this.camX + w + 30) continue;
                    
                    // Main body
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(x - 6, f.y - 25, 12, 25);
                    
                    // Left arm
                    ctx.fillRect(x - 6, f.y - 18, 8, 6);
                    
                    // Right arm
                    ctx.fillRect(x - 2, f.y - 12, 8, 6);
                }
            });
        }

        _drawSnow(ctx, w) {
            const t = performance.now();
            
            // Snow caps on floors
            this.floors.forEach(f => {
                if (f.x + f.width < this.camX || f.x > this.camX + w) return;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                for (let x = f.x + 20; x < f.x + f.width - 20; x += 50) {
                    if (x < this.camX - 15 || x > this.camX + w + 15) continue;
                    ctx.beginPath();
                    ctx.arc(x, f.y - 8, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Falling snowflakes
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const snowflakeCount = 20;
            for (let i = 0; i < snowflakeCount; i++) {
                const seed = i * 137.5;
                const x = (this.camX + (seed % w) + (t * 0.05)) % (this.finishX + w);
                const y = ((t * 0.1 + seed) % (this.canvas.height + 100)) - 50;
                
                if (x < this.camX - 10 || x > this.camX + w + 10) continue;
                if (y < 0 || y > this.canvas.height) continue;
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        _drawLava(ctx, w) {
            const t = performance.now();
            
            this.floors.forEach(f => {
                if (f.x + f.width < this.camX || f.x > this.camX + w) return;
                
                // Lava pool at floor level
                const lavaY = f.y + 70;
                const gradient = ctx.createLinearGradient(f.x, lavaY - 20, f.x, lavaY);
                gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 50, 0, 0.9)');
                gradient.addColorStop(1, 'rgba(200, 0, 0, 1)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(f.x, lavaY - 20, f.width, 20);
                
                // Bubbling effect
                ctx.fillStyle = 'rgba(255, 200, 0, 0.6)';
                for (let x = f.x + 30; x < f.x + f.width - 30; x += 60) {
                    if (x < this.camX - 20 || x > this.camX + w + 20) continue;
                    const bubbleY = lavaY - 15 + Math.sin((t * 0.003) + x * 0.01) * 5;
                    ctx.beginPath();
                    ctx.arc(x, bubbleY, 4 + Math.sin(t * 0.005 + x) * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        _drawStars(ctx, w) {
            const t = performance.now();
            const stars = [
                [200, 100], [450, 80], [700, 120], [950, 90], [1200, 110],
                [1500, 85], [1800, 105], [2100, 95], [2400, 115], [2700, 100],
                [3000, 88], [3300, 112], [3600, 92], [3900, 108], [4200, 98],
                [4500, 114], [4800, 87], [5100, 107], [5400, 102], [5700, 96]
            ];
            
            stars.forEach(([x, y], i) => {
                if (x < this.camX - 20 || x > this.camX + w + 20) return;
                
                const twinkle = (Math.sin(t * 0.002 + i) + 1) / 2;
                const opacity = 0.5 + twinkle * 0.5;
                
                ctx.fillStyle = `rgba(255, 215, 0, ${opacity})`;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Star points
                ctx.strokeStyle = `rgba(255, 215, 0, ${opacity * 0.6})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y - 4);
                ctx.lineTo(x, y + 4);
                ctx.moveTo(x - 4, y);
                ctx.lineTo(x + 4, y);
                ctx.stroke();
            });
        }

        _drawObstacles(ctx, w) {
            this.obstacles.forEach(o => {
                if (o.x + o.w < this.camX || o.x > this.camX + w) return;
                
                const centerX = o.x + o.w / 2;
                const centerY = o.y + o.h / 2;
                const radius = o.w / 2 + 6;
                
                // Animaci√≥n de mordedura
                const biteAnim = (Math.sin(o.bitePhase) + 1) / 2;
                const mouthAngle = 0.25 + biteAnim * 0.4;
                
                // Rebote
                const bounceY = Math.abs(Math.sin(o.bitePhase * 0.6)) * 4;
                
                ctx.save();
                ctx.translate(centerX, centerY - bounceY);
                
                // Voltear seg√∫n direcci√≥n
                if (o.dir < 0) ctx.scale(-1, 1);
                
                // === CUERPO NEGRO (con boca estilo Pac-Man) ===
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(0, 0, radius, mouthAngle, Math.PI * 2 - mouthAngle);
                ctx.lineTo(0, 0);
                ctx.closePath();
                ctx.fill();
                
                // Brillo superior
                ctx.fillStyle = '#3a3a3a';
                ctx.beginPath();
                ctx.ellipse(-radius * 0.25, -radius * 0.35, radius * 0.4, radius * 0.2, -0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // === OJO ===
                const eyeX = -radius * 0.3;
                const eyeY = -radius * 0.25;
                const eyeR = radius * 0.35;
                
                // Ojo blanco
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, eyeR, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupila
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(eyeX + eyeR * 0.25, eyeY, eyeR * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Brillo ojo
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(eyeX, eyeY - eyeR * 0.3, eyeR * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
        }

        _drawCoins(ctx, w) {
            const t = performance.now();
            this.coinList.forEach(c => {
                if (c.got) return;
                if (c.x < this.camX - 50 || c.x > this.camX + w + 50) return;
                
                // Aumentar amplitud de bob de 4 a 6 p√≠xeles
                const bobY = Math.sin(t / 200 + c.bob) * 6;
                
                // Agregar efecto de glow usando createRadialGradient con radio 25px y color dorado con transparencia
                const glowGradient = ctx.createRadialGradient(c.x, c.y + bobY, 0, c.x, c.y + bobY, 25);
                glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                glowGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.4)');
                glowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(c.x, c.y + bobY, 25, 0, Math.PI * 2);
                ctx.fill();
                
                // Aumentar radio de moneda de 14 a 18 p√≠xeles
                ctx.fillStyle = '#EB8225';
                ctx.beginPath();
                ctx.arc(c.x, c.y + bobY, 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(c.x - 4, c.y + bobY - 4, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Cambiar fuente de s√≠mbolo a bold 16px para mejor visibilidad
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('$', c.x, c.y + bobY + 1);
                
                // Agregar part√≠culas brillantes intermitentes cuando Math.sin(t / 100 + c.bob) > 0.8
                if (Math.sin(t / 100 + c.bob) > 0.8) {
                    const sparkleX = c.x + (Math.random() - 0.5) * 30;
                    const sparkleY = c.y + bobY + (Math.random() - 0.5) * 30;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        _drawFinish(ctx) {
            const fx = this.finishX;
            
            // Flag pole
            ctx.fillStyle = '#455A64';
            ctx.fillRect(fx, this.floorY - 130, 6, 130);
            
            // Flag
            ctx.fillStyle = '#73A03F';
            ctx.beginPath();
            ctx.moveTo(fx + 6, this.floorY - 130);
            ctx.lineTo(fx + 60, this.floorY - 105);
            ctx.lineTo(fx + 6, this.floorY - 80);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('META', fx + 33, this.floorY - 102);
            
            // Checkered pattern
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 2; j++) {
                    ctx.fillStyle = (i + j) % 2 ? '#333' : '#fff';
                    ctx.fillRect(fx - 40 + i * 12, this.floorY - 20 + j * 10, 12, 10);
                }
            }
        }

        _drawParticles(ctx) {
            this.particles.forEach(pt => {
                ctx.globalAlpha = pt.life / 30;
                
                if (pt.type === 'ring') {
                    // Anillos expansivos para feedback de salto
                    const radius = pt.radius + (30 - pt.life) * 2;
                    ctx.strokeStyle = pt.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (pt.type === 'text') {
                    // Texto flotante para contador de monedas
                    ctx.fillStyle = pt.color;
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(pt.text, pt.x, pt.y);
                } else {
                    // Part√≠culas circulares existentes
                    ctx.fillStyle = pt.color;
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1;
        }

        _drawTrail(ctx) {
            this.trail.forEach(tr => {
                ctx.globalAlpha = tr.a * 0.5;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.roundRect(tr.x + 5, tr.y + 5, this.player.w - 10, this.player.h - 10, 8);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        _drawPlayer(ctx) {
            const p = this.player;
            const t = performance.now();
            
            if (p.stunned) ctx.globalAlpha = 0.4 + Math.sin(t / 40) * 0.3;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(p.x + p.w/2, p.y + p.h + 4, p.w/2 * 0.7, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.roundRect(p.x, p.y, p.w, p.h, 12);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.roundRect(p.x + 5, p.y + 4, p.w - 10, 12, 6);
            ctx.fill();
            
            // Eyes
            const eyeY = p.y + p.h * 0.38;
            const eyeX1 = p.x + p.w * 0.3;
            const eyeX2 = p.x + p.w * 0.7;
            const lookX = p.facing * 3;
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(eyeX1, eyeY, 7, 0, Math.PI * 2);
            ctx.arc(eyeX2, eyeY, 7, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(eyeX1 + lookX, eyeY, 3, 0, Math.PI * 2);
            ctx.arc(eyeX2 + lookX, eyeY, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1;
        }

        _burst(x, y, color, count) {
            const maxParticles = 150;
            const actualCount = Math.min(count, maxParticles - this.particles.length);
            
            for (let i = 0; i < actualCount; i++) {
                this.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 3,
                    life: 25 + Math.random() * 10,
                    color
                });
            }
        }

        resize(newWidth, newHeight) {
            const oldHeight = this.canvas.height;
            
            this.canvas.width = newWidth;
            this.canvas.height = newHeight;
            
            const oldRatio = oldHeight / 700;
            const newRatio = newHeight / 700;
            const scaleY = newRatio / oldRatio;
            
            this.floorY = newHeight - 70;
            
            this.floors.forEach(f => f.y = this.floorY);
            this.platforms.forEach(p => p.y *= scaleY);
            this.coinList.forEach(c => c.y *= scaleY);
            this.obstacles.forEach(o => o.y *= scaleY);
            this.player.y *= scaleY;
        }

        loop() {
            if (!this.running) return;
            
            this.update();
            this.draw();
            
            // Update live ranking every 10 frames if overlay is visible
            if (this.num === 1 && GameManager.state.liveRankingVisible) {
                const hasWinner = Object.values(GameManager.state.games).some(g => g.won);
                if (hasWinner && (this.frameCount || 0) % 10 === 0) {
                    GameManager.updateLiveRanking();
                }
                this.frameCount = (this.frameCount || 0) + 1;
            }
            
            this.animationFrameId = requestAnimationFrame(() => this.loop());
        }

        stop() {
            this.running = false;
            if (this.animationFrameId !== null) {
                cancelAnimationFrame(this.animationFrameId);
                this.animationFrameId = null;
            }
        }
    }

    // ==========================================================================
    // GAME MANAGER
    // ==========================================================================
    
    const GameManager = {
        airconsole: null,
        isReady: false,
        pendingConnections: [],
        
        state: {
            players: {},
            games: {},
            started: false,
            starting: false,
            startTime: null,
            admin: null,
            resultsDisplayed: false,
            liveRankingVisible: false
        },
        
        _setupEventListeners() {
            DOM.elements.nextLevelBtn.addEventListener('click', () => this.goToNextLevel());
            DOM.elements.levelSelectBtn.addEventListener('click', () => this.restart());
            
            let resizeTimeout;
            window.addEventListener('resize', () => {
                if (this.state.started) {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        for (let n in this.state.games) {
                            const g = this.state.games[n];
                            const container = DOM.get(`screen${n}`);
                            if (container && g.canvas) {
                                g.resize(container.clientWidth, container.clientHeight);
                            }
                        }
                    }, 100);
                }
            });
        },
        
        _handleConnect(id) {
            // Ignore screen device (id = 0)
            if (id === AirConsole.SCREEN || id === 0) return;
            
            // If not ready yet, queue the connection for later
            if (!this.isReady) {
                this.pendingConnections.push(id);
                return;
            }
            
            // Check if this device is already connected (reconnection)
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (this.state.players[slot] && this.state.players[slot].deviceId === id) {
                    // Device reconnecting to same slot - always mark as connected and send message
                    this.state.players[slot].disconnected = false;
                    
                    // Send reconnect message immediately
                    airconsole.message(id, {
                        action: 'reconnected',
                        playerNum: slot,
                        color: this.state.players[slot].color,
                        colorName: this.state.players[slot].name,
                        isAdmin: this.state.players[slot].isAdmin
                    });
                    
                    UIManager.updatePlayerSlots(this.state.players, this.state.admin);
                    
                    // Delay broadcast to ensure device is fully registered
                    setTimeout(function() {
                        airconsole.broadcast({ action: 'gameState', players: GameManager.state.players });
                    }, 100);
                    
                    return;
                }
            }
            
            // Check if game is full before allowing join
            let availableSlots = 0;
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (!this.state.players[slot]) {
                    availableSlots++;
                }
            }
            
            if (availableSlots === 0) {
                // Game is full
                airconsole.message(id, { action: 'gameFull' });
                return;
            }
            
            // Send message to controller that they can join (but don't assign yet)
            airconsole.message(id, { action: 'canJoin' });
        },
        
        _handleDisconnect(id) {
            // Find player by device ID
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (this.state.players[slot] && this.state.players[slot].deviceId === id) {
                    this.state.players[slot].disconnected = true;
                    UIManager.updatePlayerSlots(this.state.players, this.state.admin);
                    
                    GameManager.airconsole.broadcast({ 
                        action: 'playerDisconnected', 
                        playerNum: slot,
                        playerName: this.state.players[slot].name
                    });
                    return;
                }
            }
        },
        
        _handleMessage(id, data) {
            // Find player slot by device ID
            let playerSlot = null;
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (this.state.players[slot] && this.state.players[slot].deviceId === id) {
                    playerSlot = slot;
                    break;
                }
            }
            
            switch (data.action) {
                case 'requestJoin':
                    this._handleRequestJoin(id);
                    break;
                    
                case 'join':
                    this._handleJoinRequest(id, playerSlot);
                    break;
                    
                case 'selectColor':
                    this._handleColorSelect(id, data);
                    break;
                    
                case 'startGame':
                    if (playerSlot === this.state.admin) this.startGame();
                    break;
                    
                case 'playAgain':
                    if (playerSlot === this.state.admin) this.restart();
                    break;
                    
                case 'nextLevel':
                    if (playerSlot === this.state.admin) this.goToNextLevel();
                    break;
                    
                case 'goToLevelSelect':
                    if (playerSlot === this.state.admin) this.restart();
                    break;
                    
                case 'move':
                case 'stop':
                case 'jump':
                    this._handleGameInput(playerSlot, data);
                    break;
            }
        },
        
        _handleRequestJoin(id) {
            // Check if this device is already assigned
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (this.state.players[slot] && this.state.players[slot].deviceId === id) {
                    // Already joined - send joined message
                    const p = this.state.players[slot];
                    airconsole.message(id, {
                        action: 'joined',
                        playerNum: slot,
                        color: p.color,
                        colorName: p.name,
                        isAdmin: p.isAdmin
                    });
                    return;
                }
            }
            
            // Check if game is full
            let availableSlots = 0;
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (!this.state.players[slot]) {
                    availableSlots++;
                }
            }
            
            if (availableSlots === 0) {
                // Game is full
                airconsole.message(id, { action: 'gameFull' });
                return;
            }
            
            // Send canJoin message
            airconsole.message(id, { action: 'canJoin' });
        },
        
        _handleJoinRequest(id, playerSlot) {
            // If player is already assigned, just resend the joined message
            if (playerSlot && this.state.players[playerSlot]) {
                const p = this.state.players[playerSlot];
                airconsole.message(id, {
                    action: 'joined',
                    playerNum: playerSlot,
                    color: p.color,
                    colorName: p.name,
                    isAdmin: p.isAdmin
                });
                return;
            }
            
            // New player wants to join - assign them a slot
            // Check if game is full
            let availableSlot = null;
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (!this.state.players[slot]) {
                    availableSlot = slot;
                    break;
                }
            }
            
            if (availableSlot === null) {
                // Game is full
                airconsole.message(id, { action: 'gameFull' });
                return;
            }
            
            // Assign player to slot
            const playerIndex = availableSlot - 1;
            const isAdmin = !this.state.admin;
            if (isAdmin) this.state.admin = availableSlot;
            
            this.state.players[availableSlot] = {
                deviceId: id,
                playerNumber: playerIndex,
                name: CONFIG.NAMES[playerIndex],
                color: CONFIG.COLORS[playerIndex],
                isAdmin: isAdmin,
                disconnected: false
            };
            
            // Send joined message to controller
            airconsole.message(id, {
                action: 'joined',
                playerNum: availableSlot,
                color: CONFIG.COLORS[playerIndex],
                colorName: CONFIG.NAMES[playerIndex],
                isAdmin: isAdmin
            });
            
            UIManager.updatePlayerSlots(this.state.players, this.state.admin);
            
            // Delay broadcast to ensure device is fully registered
            setTimeout(function() {
                airconsole.broadcast({ action: 'gameState', players: GameManager.state.players });
            }, 100);
        },
        
        _handleColorSelect(id, data) {
            for (let n in this.state.players) {
                if (this.state.players[n].deviceId === id) {
                    this.state.players[n].color = data.color;
                    this.state.players[n].name = data.colorName;
                    UIManager.updatePlayerSlots(this.state.players, this.state.admin);
                    GameManager.airconsole.message(id, { action: 'colorUpdated', color: data.color, colorName: data.colorName });
                    break;
                }
            }
        },
        
        _handleGameInput(playerSlot, data) {
            console.log('Input received:', playerSlot, data, 'started:', this.state.started);
            if (playerSlot && this.state.games[playerSlot]) {
                const g = this.state.games[playerSlot];
                console.log('Processing input for player', playerSlot, '- keys:', g.keys);
                
                if (data.action === 'move') {
                    g.keys.left = data.direction === 'left';
                    g.keys.right = data.direction === 'right';
                } else if (data.action === 'stop') {
                    g.keys.left = g.keys.right = false;
                } else if (data.action === 'jump') {
                    g.keys.jump = data.pressed;
                }
            }
        },
        
        async startGame() {
            if (this.state.started || this.state.starting) return;
            this.state.starting = true;
            
            DOM.elements.startScreen.style.display = 'none';
            DOM.elements.gameContainer.style.display = 'block';
            
            const players = Object.values(this.state.players).filter(p => !p.disconnected);
            this._setupScreens(players.length);
            
            for (let n in this.state.players) {
                if (!this.state.players[n].disconnected) {
                    this.state.games[n] = new Game(n, this.state.players[n].color, this.state.players[n].name);
                    this.state.games[n].init();
                }
            }
            
            await UIManager.countdown();
            
            this.state.started = true;
            this.state.starting = false;
            this.state.startTime = Date.now();
            GameManager.airconsole.broadcast({ action: 'gameStart' });
        },
        
        _setupScreens(count) {
            const container = DOM.elements.gameContainer;
            container.innerHTML = '';
            
            // Add flexbox layout to container based on player count
            if (count === 2) {
                container.style.cssText = 'display:flex;flex-direction:row;gap:6px;';
            } else if (count >= 3) {
                container.style.cssText = 'display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr;gap:6px;';
            } else {
                container.style.cssText = '';
            }
            
            let i = 0;
            for (let n in this.state.players) {
                if (this.state.players[n].disconnected) continue;
                const p = this.state.players[n];
                
                const div = document.createElement('div');
                div.id = `screen${n}`;
                div.className = 'relative overflow-hidden rounded-lg';
                
                // Improved Layout - side by side for 2 players
                if (count === 1) {
                    div.style.cssText = 'position:absolute;inset:0;';
                } else if (count === 2) {
                    div.style.cssText = 'flex:1;height:100%;';
                } else if (count === 3) {
                    if (i === 0) div.style.cssText = 'grid-column:1;grid-row:1;';
                    else if (i === 1) div.style.cssText = 'grid-column:2;grid-row:1;';
                    else div.style.cssText = 'grid-column:1/3;grid-row:2;';
                } else {
                    // 4 players - 2x2 grid
                    div.style.cssText = '';
                }
                
                const levelData = LevelManager.getLevelData();
                div.innerHTML = `
                    <canvas id="canvas${n}" class="absolute inset-0 w-full h-full"></canvas>
                    <div class="absolute top-1 left-1 bg-black/80 rounded-md py-0.5 px-2 flex items-center gap-1 text-white font-bold text-xs z-10">
                        <iconify-icon icon="mdi:cash-multiple" class="text-yellow-400 text-sm"></iconify-icon>
                        <span id="coins${n}">0</span>/<span>${levelData.coins.length}</span>
                    </div>
                    <div class="absolute top-1 right-1 bg-black/80 rounded-md py-0.5 px-2 flex items-center gap-1 font-bold z-10">
                        <div class="w-4 h-4 rounded relative" style="background:${p.color}">
                            <span class="absolute top-0.5 left-0.5 w-1 h-1 bg-white rounded-full"></span>
                            <span class="absolute top-0.5 right-0.5 w-1 h-1 bg-white rounded-full"></span>
                        </div>
                        <span class="text-white text-xs">${p.name}</span>
                    </div>
                    <div class="absolute bottom-1 left-1 right-1 flex items-center gap-1 z-10">
                        <div class="flex-1 h-1 bg-black/40 rounded-full overflow-hidden">
                            <div id="progress${n}" class="h-full rounded-full transition-all" style="width:0%;background:${p.color}"></div>
                        </div>
                        <div class="bg-black/80 rounded px-1 py-0.5 text-white text-[10px] font-bold">
                            Nv${LevelManager.progress.currentLevel}
                        </div>
                    </div>
                `;
                
                if (count > 1) {
                    div.style.border = `3px solid ${p.color}`;
                    div.style.boxShadow = `0 0 10px ${p.color}40`;
                }
                
                container.appendChild(div);
                i++;
            }
        },
        
        showResults() {
            const results = [];
            
            for (let n in this.state.games) {
                const g = this.state.games[n];
                const p = this.state.players[n];
                if (g.finishTime && !p.disconnected) {
                    const timeBonus = Math.max(0, 1000 - (g.finishTime - this.state.startTime) / 100);
                    const coinBonus = g.coins * 100;
                    results.push({
                        num: n,
                        name: p.name,
                        color: p.color,
                        coins: g.coins,
                        time: ((g.finishTime - this.state.startTime) / 1000).toFixed(1),
                        score: Math.round(timeBonus + coinBonus)
                    });
                }
            }
            
            results.sort((a, b) => b.score - a.score);
            
            const levelCompleted = results.length > 0;
            if (levelCompleted) {
                LevelManager.completeLevel(LevelManager.progress.currentLevel);
            }
            
            UIManager.showResults(results, levelCompleted, LevelManager.hasNextLevel());
            
            GameManager.airconsole.broadcast({ 
                action: 'gameResults', 
                results, 
                winner: results[0], 
                levelCompleted, 
                hasNextLevel: LevelManager.hasNextLevel() 
            });
        },

        showLiveRankingOverlay(winnerNum) {
            const winner = this.state.players[winnerNum];
            if (!winner) return;
            
            const winnerInfoEl = DOM.get('winnerInfo');
            if (winnerInfoEl) {
                winnerInfoEl.innerHTML = `
                    <div class="player-avatar mx-auto mb-2" style="background:${winner.color};width:80px;height:80px;border-radius:16px;box-shadow:0 0 20px ${winner.color}50"></div>
                    <div class="text-2xl font-black" style="color:${winner.color}">${winner.name}</div>
                `;
            }
            
            this.updateLiveRanking();
            
            const overlay = DOM.get('liveRankingOverlay');
            if (overlay) {
                overlay.classList.remove('hidden');
                this.state.liveRankingVisible = true;
            }
            
            AudioManager.play('win');
        },

        updateLiveRanking() {
            const players = [];
            
            for (let n in this.state.games) {
                const g = this.state.games[n];
                const p = this.state.players[n];
                if (!p || p.disconnected) continue;
                
                players.push({
                    num: n,
                    name: p.name,
                    color: p.color,
                    finished: g.won,
                    finishTime: g.finishTime,
                    position: g.player?.x || 0,
                    coins: g.coins || 0
                });
            }
            
            // Sort: finished players first (by finish time), then by current x position
            players.sort((a, b) => {
                if (a.finished && b.finished) {
                    return a.finishTime - b.finishTime;
                }
                if (a.finished) return -1;
                if (b.finished) return 1;
                return b.position - a.position;
            });
            
            this.displayLiveRanking(players);
        },

        displayLiveRanking(players) {
            const listEl = DOM.get('livePositionList');
            if (!listEl) return;
            
            let html = '';
            players.forEach((player, index) => {
                const position = index + 1;
                const status = player.finished ? '‚úÖ Termin√≥' : 'üèÉ Corriendo';
                const borderColor = player.color;
                
                html += `
                    <div class="position-item" style="border-left-color: ${borderColor}">
                        <div class="text-2xl font-bold text-steam-turquesa w-8 text-center">${position}</div>
                        <div class="flex-1">
                            <div class="font-bold" style="color: ${player.color}">${player.name}</div>
                            <div class="text-sm text-gray-600">${status}</div>
                        </div>
                    </div>
                `;
            });
            
            listEl.innerHTML = html;
        },

        hideLiveRankingOverlay() {
            const overlay = DOM.get('liveRankingOverlay');
            if (overlay) {
                overlay.classList.add('hidden');
                this.state.liveRankingVisible = false;
            }
        },
        
        restart() {
            if (!this.state.resultsDisplayed) return;
            
            DOM.elements.resultsScreen.style.display = 'none';
            DOM.elements.startScreen.style.display = 'flex';
            DOM.elements.gameContainer.style.display = 'none';
            
            // Stop all games
            for (let n in this.state.games) {
                if (this.state.games[n]?.stop) {
                    this.state.games[n].stop();
                }
            }
            
            this.state.started = false;
            this.state.starting = false;
            this.state.games = {};
            this.state.resultsDisplayed = false;
            this.state.liveRankingVisible = false;
            
            // Hide overlay if visible
            this.hideLiveRankingOverlay();
            
            // Remove disconnected players
            for (let n in this.state.players) {
                if (this.state.players[n].disconnected) {
                    delete this.state.players[n];
                }
            }
            
            UIManager.updatePlayerSlots(this.state.players, this.state.admin);
            LevelManager.updateButtons();
            GameManager.airconsole.broadcast({ action: 'gameRestart' });
        },
        
        goToNextLevel() {
            if (!this.state.resultsDisplayed) return;
            
            const nextLevel = LevelManager.progress.currentLevel + 1;
            if (nextLevel <= 5) {
                LevelManager.selectLevel(nextLevel);
                this.restart();
            }
        }
    };

    // ==========================================================================
    // INITIALIZATION (following AirConsole quick-start pattern)
    // ==========================================================================
    
    // Initialize DOM
    DOM.init();
    
    // Create AirConsole instance
    var airconsole = new AirConsole();
    GameManager.airconsole = airconsole;
    
    // AirConsole ready handler
    airconsole.onReady = function() {
        GameManager.isReady = true;
        
        // Process any connections that arrived before ready
        GameManager.pendingConnections.forEach(function(id) {
            GameManager._handleConnect(id);
        });
        GameManager.pendingConnections = [];
    };
    
    // Handle new device connections
    airconsole.onConnect = function(device_id) {
        GameManager._handleConnect(device_id);
    };
    
    // Handle device disconnections
    airconsole.onDisconnect = function(device_id) {
        GameManager._handleDisconnect(device_id);
    };
    
    // Listen for messages from controllers
    airconsole.onMessage = function(from, data) {
        if (data && data.action) {
            GameManager._handleMessage(from, data);
        }
    };
    
    // Setup UI and level selector
    GameManager._setupEventListeners();
    LevelManager.init();
    
    // ==========================================================================
    // KEYBOARD CONTROLS FOR PC TESTING
    // ==========================================================================
    
    const KeyboardControls = {
        enabled: true,
        activePlayer: null,
        
        init() {
            window.addEventListener('keydown', (e) => this._handleKey(e, true));
            window.addEventListener('keyup', (e) => this._handleKey(e, false));
        },
        
        _getActivePlayer() {
            // Find first connected player
            for (let slot = 1; slot <= CONFIG.MAX_PLAYERS; slot++) {
                if (GameManager.state.players[slot] && !GameManager.state.players[slot].disconnected) {
                    return slot;
                }
            }
            return null;
        },
        
        _handleKey(e, pressed) {
            if (!this.enabled || !GameManager.state.started) return;
            
            const playerSlot = this._getActivePlayer();
            if (!playerSlot || !GameManager.state.games[playerSlot]) return;
            
            const game = GameManager.state.games[playerSlot];
            
            // Arrow keys or WASD
            switch (e.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    e.preventDefault();
                    if (pressed) {
                        game.keys.left = true;
                        game.keys.right = false;
                    } else {
                        game.keys.left = false;
                    }
                    break;
                    
                case 'ArrowRight':
                case 'KeyD':
                    e.preventDefault();
                    if (pressed) {
                        game.keys.right = true;
                        game.keys.left = false;
                    } else {
                        game.keys.right = false;
                    }
                    break;
                    
                case 'ArrowUp':
                case 'KeyW':
                case 'Space':
                    e.preventDefault();
                    game.keys.jump = pressed;
                    break;
            }
        }
    };
    
    KeyboardControls.init();
    </script>
</body>
</html>