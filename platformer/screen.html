<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>STEAM Platformer - Fundacion STEAM RD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
    <script type="text/javascript" src="https://www.airconsole.com/api/airconsole-1.8.0.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        steam: {
                            turquesa: '#0595AE',
                            morado: '#AB3D8B',
                            naranja: '#EB8225',
                            verde: '#73A03F',
                            negro: '#010101',
                            blanco: '#FFFFFF'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        body { position: fixed; top: 0; left: 0; font-family: 'Segoe UI', system-ui, sans-serif; background: #f8f9fa; }

        /* Clean title with colored letters */
        .title-steam { color: #0595AE; }
        .title-platformer { color: #73A03F; }

        /* Player avatar - clean flat design */
        .player-avatar {
            width: clamp(50px, 8vw, 80px);
            height: clamp(50px, 8vw, 80px);
            border-radius: 16px;
            position: relative;
            box-shadow: 0 6px 0 rgba(0,0,0,0.15), 0 8px 25px rgba(0,0,0,0.1);
        }

        /* Eyes for avatar - simple centered with idle blink */
        .player-avatar::before,
        .player-avatar::after {
            content: '';
            position: absolute;
            width: 24%;
            height: 24%;
            top: 32%;
            background: radial-gradient(circle at 50% 50%, #222 35%, transparent 36%),
                        white;
            border-radius: 50%;
            animation: idleBlink 4s ease-in-out infinite;
        }
        .player-avatar::before { left: 18%; }
        .player-avatar::after { right: 18%; animation-delay: 0.05s; }

        /* Idle blink - natural blinking */
        @keyframes idleBlink {
            0%, 42%, 48%, 100% { transform: scaleY(1); }
            45% { transform: scaleY(0.05); }
        }

        /* Happy blink when player connects */
        .player-card.ready .player-avatar::before,
        .player-card.ready .player-avatar::after,
        .player-card.admin .player-avatar::before,
        .player-card.admin .player-avatar::after {
            animation: blinkHappy 0.6s ease-out, idleBlink 4s ease-in-out 0.6s infinite;
        }
        @keyframes blinkHappy {
            0% { transform: scaleY(1); }
            20% { transform: scaleY(0.05); }
            40% { transform: scaleY(1); }
            60% { transform: scaleY(0.05); }
            80% { transform: scaleY(1); }
            100% { transform: scaleY(1); }
        }

        /* Jump when connected */
        .player-card.ready .player-avatar,
        .player-card.admin .player-avatar {
            animation: happyJump 0.5s ease-out;
        }
        @keyframes happyJump {
            0% { transform: scale(1); }
            40% { transform: scale(1.15) translateY(-12px); }
            70% { transform: scale(0.95) translateY(0); }
            100% { transform: scale(1) translateY(0); }
        }

        .player-avatar-small {
            width: clamp(35px, 5vw, 50px);
            height: clamp(35px, 5vw, 50px);
            border-radius: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.15);
        }

        /* Float animation */
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        .float { animation: float 3s ease-in-out infinite; }

        /* Player card */
        .player-card {
            background: white;
            border-radius: 20px;
            padding: clamp(16px, 3vw, 28px);
            border: 4px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .player-card.ready {
            border-color: #73A03F;
            background: #f0fdf4;
        }

        .player-card.admin {
            border-color: #EB8225;
            background: #fff7ed;
        }

        /* Countdown */
        .countdown-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .countdown-number {
            font-size: clamp(120px, 30vw, 250px);
            font-weight: 900;
            color: white;
            text-shadow: 0 0 60px currentColor;
            animation: countPop 0.6s ease-out;
        }

        @keyframes countPop {
            0% { transform: scale(2.5); opacity: 0; }
            60% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Confetti */
        @keyframes fall {
            to { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .confetti {
            position: absolute;
            animation: fall 3s ease-out forwards;
        }

        /* Pulse */
        @keyframes pulse {
            50% { opacity: 0.6; }
        }
        .pulse { animation: pulse 2s ease infinite; }

        /* Winner animation */
        @keyframes winner {
            0% { transform: scale(0) rotate(-10deg); }
            70% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        .winner-anim { animation: winner 0.6s ease-out; }
    </style>
</head>
<body>
    <!-- START SCREEN -->
    <div id="startScreen" class="w-screen h-screen flex flex-col items-center justify-center p-6 text-center bg-gray-50">
        <div class="mb-6">
            <h1 class="text-4xl sm:text-5xl lg:text-6xl font-black mb-2 flex items-center justify-center gap-3">
                <iconify-icon icon="mdi:gamepad-variant" class="text-steam-turquesa"></iconify-icon>
                <span class="title-steam">STEAM</span> <span class="title-platformer">PLATFORMER</span>
            </h1>
            <p class="text-gray-500 text-lg flex items-center justify-center gap-3">
                <iconify-icon icon="mdi:run-fast"></iconify-icon>
                Corre
                <iconify-icon icon="mdi:arrow-up-bold-box"></iconify-icon>
                Salta
                <iconify-icon icon="mdi:cash-multiple"></iconify-icon>
                Colecta
            </p>
        </div>
        
        <div class="grid grid-cols-2 gap-4 sm:gap-6 mb-8 w-full max-w-xl lg:max-w-3xl">
            <div class="player-card" id="playerSlot1">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 1
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
            <div class="player-card" id="playerSlot2">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 2
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
            <div class="player-card" id="playerSlot3">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 3
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
            <div class="player-card" id="playerSlot4">
                <div class="text-lg sm:text-xl font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                    <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                    Jugador 4
                </div>
                <div class="flex justify-center mb-3 float">
                    <div class="player-avatar bg-gray-300"></div>
                </div>
                <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                    <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                    Esperando...
                </div>
            </div>
        </div>
        
        <div class="bg-steam-naranja/10 border-2 border-steam-naranja rounded-2xl py-4 px-8 hidden flex items-center gap-3" id="adminHint">
            <iconify-icon icon="mdi:cellphone" class="text-steam-naranja text-2xl"></iconify-icon>
            <p class="text-steam-naranja font-bold">El Jugador 1 inicia desde su telefono</p>
        </div>
        
        <!-- Level Selection -->
        <div class="mt-6 hidden" id="levelSelector">
            <h3 class="text-lg font-bold text-steam-turquesa mb-3 flex items-center justify-center gap-2">
                <iconify-icon icon="mdi:map-marker-path"></iconify-icon>
                Selecciona Nivel
            </h3>
            <div class="flex gap-2 justify-center flex-wrap max-w-md mx-auto">
                <button class="level-btn bg-steam-verde text-white font-bold py-2 px-4 rounded-xl border-2 border-steam-verde" data-level="1">1</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="2">2</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="3">3</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="4">4</button>
                <button class="level-btn bg-gray-300 text-gray-600 font-bold py-2 px-4 rounded-xl border-2 border-gray-300" data-level="5">5</button>
            </div>
            <p class="text-sm text-gray-500 mt-2 text-center" id="levelName">Inicio Facil</p>
        </div>
    </div>

    <!-- GAME CONTAINER -->
    <div id="gameContainer" class="hidden w-screen h-screen fixed inset-0 overflow-hidden"></div>

    <!-- COUNTDOWN -->
    <div id="countdownOverlay" class="countdown-overlay hidden">
        <div class="countdown-number" id="countdownNumber">3</div>
    </div>

    <!-- RESULTS SCREEN -->
    <div id="resultsScreen" class="hidden fixed inset-0 flex items-center justify-center z-50 p-4 bg-gray-50">
        <div class="bg-white rounded-3xl p-6 sm:p-10 text-center w-full max-w-2xl shadow-2xl max-h-[95vh] overflow-y-auto">
            <h2 class="text-3xl sm:text-4xl font-black text-steam-turquesa mb-6 flex items-center justify-center gap-3">
                <iconify-icon icon="mdi:flag-checkered"></iconify-icon>
                Fin de Carrera!
            </h2>
            <div class="winner-anim mb-8" id="winnerSection"></div>
            <table class="w-full mb-8 text-left">
                <thead>
                    <tr class="border-b-4 border-gray-100">
                        <th class="py-3 px-2 text-steam-turquesa font-bold">#</th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold">
                            <span class="flex items-center gap-1">
                                <iconify-icon icon="mdi:account"></iconify-icon>
                                Jugador
                            </span>
                        </th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold text-center">
                            <span class="flex items-center justify-center gap-1">
                                <iconify-icon icon="mdi:cash"></iconify-icon>
                                Monedas
                            </span>
                        </th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold text-center">
                            <span class="flex items-center justify-center gap-1">
                                <iconify-icon icon="mdi:timer"></iconify-icon>
                                Tiempo
                            </span>
                        </th>
                        <th class="py-3 px-2 text-steam-turquesa font-bold text-right">
                            <span class="flex items-center justify-end gap-1">
                                <iconify-icon icon="mdi:star"></iconify-icon>
                                Puntos
                            </span>
                        </th>
                    </tr>
                </thead>
                <tbody id="resultsBody"></tbody>
            </table>
            <div class="flex gap-4" id="resultsActions">
                <button class="btn btn-turquesa py-4 px-8 text-base hidden pulse flex items-center gap-2" id="nextLevelBtn">
                    <iconify-icon icon="mdi:arrow-right-bold"></iconify-icon>
                    SIGUIENTE NIVEL
                </button>
                <button class="btn btn-morado py-4 px-8 text-base hidden pulse flex items-center gap-2" id="levelSelectBtn">
                    <iconify-icon icon="mdi:map-marker-path"></iconify-icon>
                    SELECCIONAR NIVEL
                </button>
            </div>
            <div class="bg-steam-naranja/10 border-2 border-steam-naranja rounded-xl py-4 px-6 pulse flex items-center justify-center gap-2" id="waitingAdmin">
                <iconify-icon icon="mdi:cellphone" class="text-steam-naranja text-xl"></iconify-icon>
                <p class="text-steam-naranja font-bold">Esperando al Jugador 1...</p>
            </div>
        </div>
    </div>

    <!-- CONFETTI -->
    <div class="fixed inset-0 pointer-events-none z-[1000] overflow-hidden" id="confettiContainer"></div>

    <script>
        const airconsole = new AirConsole();
        
        // Physics configuration - centralized for easy tuning
        const PHYSICS_CONFIG = {
            gravity: 0.6,              // Gravity acceleration per frame
            maxFallSpeed: 16,          // Terminal velocity when falling
            moveSpeed: 6.0,            // Base horizontal movement speed
            jumpPower: -14,            // Initial jump velocity (negative = up)
            airAcceleration: 0.5,      // Acceleration multiplier in air
            groundAcceleration: 0.8,   // Acceleration multiplier on ground
            friction: 0.7,             // Ground friction (lower = more slide)
            airResistance: 0.95,       // Air resistance when stunned
            jumpCutMultiplier: 0.5,    // Jump height reduction when button released
            jumpCutThreshold: -4       // Minimum upward velocity for jump cutting
        };
        
        // Multi-level system with progressive difficulty
        const LEVELS = {
            1: {
                name: "Inicio Facil",
                length: 2500,
                floorSegments: [
                    { x: 0, width: 500 },
                    { x: 700, width: 400 },
                    { x: 1300, width: 500 },
                    { x: 2000, width: 500 },
                ],
                platforms: [
                    { x: 350, y: 550, width: 180 },       // Platform 1
                    { x: 700, y: 500, width: 150 },       // Platform 2 - moved right for spacing
                    { x: 1050, y: 540, width: 160 },      // Platform 3 - adjusted spacing
                    { x: 1550, y: 520, width: 180 },      // Platform 4
                    { x: 1900, y: 490, width: 160 },      // Platform 5
                ],
                coins: [
                    { x: 440, y: 510 }, { x: 775, y: 460 }, { x: 1130, y: 500 },
                    { x: 1630, y: 480 }, { x: 1980, y: 450 }, { x: 2250, y: 550 },
                ],
                obstacles: [
                    { x: 590, y: 340, startX: 590 },      // Obstacle 1 - moved for safe zone
                    { x: 1350, y: 330, startX: 1350 },    // Obstacle 2 - moved for safe zone
                ],
            },
            2: {
                name: "Saltos Medianos",
                length: 3000,
                floorSegments: [
                    { x: 0, width: 400 },
                    { x: 650, width: 300 },             // Increased gap to 250px
                    { x: 1150, width: 450 },            // Adjusted for 200px gap
                    { x: 1800, width: 350 },            // Adjusted for 200px gap
                    { x: 2350, width: 650 },            // Adjusted for 200px gap
                ],
                platforms: [
                    { x: 300, y: 550, width: 150 },
                    { x: 550, y: 480, width: 120 },     // Adjusted spacing
                    { x: 850, y: 530, width: 180 },     // Better spacing from obstacle
                    { x: 1100, y: 460, width: 140 },
                    { x: 1400, y: 510, width: 160 },
                    { x: 1650, y: 440, width: 130 },
                    { x: 1950, y: 490, width: 200 },
                    { x: 2250, y: 530, width: 150 },
                    { x: 2550, y: 470, width: 180 },
                ],
                coins: [
                    { x: 375, y: 510 }, { x: 610, y: 440 }, { x: 930, y: 490 },
                    { x: 1170, y: 420 }, { x: 1480, y: 470 }, { x: 1715, y: 400 },
                    { x: 2050, y: 450 }, { x: 2325, y: 490 }, { x: 2630, y: 430 },
                    { x: 2850, y: 550 },
                ],
                obstacles: [
                    { x: 470, y: 320, startX: 470 },    // Better safe zone
                    { x: 1000, y: 300, startX: 1000 },  // Better safe zone
                    { x: 1550, y: 280, startX: 1550 },  // Better safe zone
                    { x: 2150, y: 310, startX: 2150 },  // Better safe zone
                ],
            },
            3: {
                name: "Torre Alta",
                length: 3500,
                floorSegments: [
                    { x: 0, width: 350 },
                    { x: 600, width: 250 },             // 250px gap (hard level)
                    { x: 1100, width: 200 },            // 250px gap
                    { x: 1550, width: 300 },            // 250px gap
                    { x: 2100, width: 250 },            // 250px gap
                    { x: 2600, width: 400 },            // 250px gap
                    { x: 3250, width: 250 },            // 250px gap
                ],
                platforms: [
                    { x: 250, y: 570, width: 130 },
                    { x: 480, y: 510, width: 120 },     // Better spacing
                    { x: 710, y: 450, width: 110 },
                    { x: 950, y: 500, width: 130 },     // Better spacing from obstacle
                    { x: 1200, y: 440, width: 140 },
                    { x: 1450, y: 380, width: 120 },
                    { x: 1750, y: 520, width: 150 },
                    { x: 2000, y: 460, width: 130 },
                    { x: 2300, y: 400, width: 140 },
                    { x: 2550, y: 480, width: 150 },
                    { x: 2850, y: 520, width: 160 },
                    { x: 3150, y: 470, width: 140 },
                ],
                coins: [
                    { x: 315, y: 530 }, { x: 540, y: 470 }, { x: 770, y: 410 },
                    { x: 1010, y: 460 }, { x: 1270, y: 400 }, { x: 1510, y: 340 },
                    { x: 1820, y: 480 }, { x: 2060, y: 420 }, { x: 2370, y: 360 },
                    { x: 2610, y: 440 }, { x: 2920, y: 480 }, { x: 3210, y: 430 },
                ],
                obstacles: [
                    { x: 390, y: 300, startX: 390 },    // Better safe zone
                    { x: 850, y: 280, startX: 850 },    // Better safe zone
                    { x: 1350, y: 260, startX: 1350 },  // Better safe zone
                    { x: 1900, y: 270, startX: 1900 },  // Better safe zone
                    { x: 2450, y: 250, startX: 2450 },  // Better safe zone
                    { x: 3000, y: 280, startX: 3000 },  // Better safe zone
                ],
            },
            4: {
                name: "Abismo Peligroso",
                length: 4000,
                floorSegments: [
                    { x: 0, width: 300 },
                    { x: 550, width: 200 },             // 250px gap (expert level)
                    { x: 1000, width: 250 },            // 250px gap
                    { x: 1500, width: 200 },            // 250px gap
                    { x: 1950, width: 300 },            // 250px gap
                    { x: 2500, width: 200 },            // 250px gap
                    { x: 2950, width: 250 },            // 250px gap
                    { x: 3450, width: 300 },            // 250px gap
                    { x: 4000, width: 0 },              // Finish line
                ],
                platforms: [
                    { x: 200, y: 560, width: 120 },
                    { x: 420, y: 500, width: 100 },
                    { x: 630, y: 440, width: 110 },
                    { x: 850, y: 490, width: 120 },
                    { x: 1070, y: 530, width: 130 },
                    { x: 1300, y: 470, width: 110 },
                    { x: 1550, y: 410, width: 120 },
                    { x: 1800, y: 500, width: 130 },
                    { x: 2050, y: 450, width: 120 },
                    { x: 2300, y: 490, width: 110 },
                    { x: 2600, y: 430, width: 120 },
                    { x: 2850, y: 510, width: 130 },
                    { x: 3100, y: 460, width: 110 },
                    { x: 3350, y: 500, width: 120 },
                    { x: 3600, y: 450, width: 130 },
                ],
                coins: [
                    { x: 260, y: 520 }, { x: 480, y: 460 }, { x: 690, y: 400 },
                    { x: 910, y: 450 }, { x: 1130, y: 490 }, { x: 1360, y: 430 },
                    { x: 1610, y: 370 }, { x: 1860, y: 460 }, { x: 2110, y: 410 },
                    { x: 2360, y: 450 }, { x: 2660, y: 390 }, { x: 2910, y: 470 },
                    { x: 3160, y: 420 }, { x: 3410, y: 460 }, { x: 3660, y: 410 },
                ],
                obstacles: [
                    { x: 340, y: 310, startX: 340 },
                    { x: 750, y: 290, startX: 750 },
                    { x: 1200, y: 280, startX: 1200 },
                    { x: 1680, y: 270, startX: 1680 },
                    { x: 2180, y: 280, startX: 2180 },
                    { x: 2730, y: 270, startX: 2730 },
                    { x: 3230, y: 280, startX: 3230 },
                    { x: 3750, y: 270, startX: 3750 },
                ],
            },
            5: {
                name: "Maestro Supremo",
                length: 4500,
                floorSegments: [
                    { x: 0, width: 250 },
                    { x: 550, width: 180 },             // 300px gap (master level - extreme)
                    { x: 1030, width: 200 },            // 300px gap
                    { x: 1530, width: 180 },            // 300px gap
                    { x: 2010, width: 220 },            // 300px gap
                    { x: 2530, width: 180 },            // 300px gap
                    { x: 3010, width: 200 },            // 300px gap
                    { x: 3510, width: 180 },            // 300px gap
                    { x: 3990, width: 510 },            // Final stretch
                ],
                platforms: [
                    { x: 170, y: 570, width: 100 },
                    { x: 350, y: 520, width: 90 },
                    { x: 580, y: 460, width: 100 },
                    { x: 750, y: 510, width: 90 },
                    { x: 930, y: 450, width: 100 },
                    { x: 1130, y: 390, width: 90 },
                    { x: 1330, y: 530, width: 100 },
                    { x: 1580, y: 470, width: 90 },
                    { x: 1780, y: 410, width: 100 },
                    { x: 2030, y: 350, width: 90 },
                    { x: 2280, y: 500, width: 100 },
                    { x: 2480, y: 440, width: 90 },
                    { x: 2680, y: 490, width: 100 },
                    { x: 2880, y: 430, width: 90 },
                    { x: 3080, y: 380, width: 100 },
                    { x: 3330, y: 520, width: 90 },
                    { x: 3580, y: 460, width: 100 },
                    { x: 3830, y: 400, width: 90 },
                    { x: 4080, y: 510, width: 100 },
                    { x: 4330, y: 450, width: 90 },
                ],
                coins: [
                    { x: 220, y: 530 }, { x: 400, y: 480 }, { x: 630, y: 420 },
                    { x: 800, y: 470 }, { x: 980, y: 410 }, { x: 1180, y: 350 },
                    { x: 1380, y: 490 }, { x: 1630, y: 430 }, { x: 1830, y: 370 },
                    { x: 2080, y: 310 }, { x: 2330, y: 460 }, { x: 2530, y: 400 },
                    { x: 2730, y: 450 }, { x: 2930, y: 390 }, { x: 3130, y: 340 },
                    { x: 3380, y: 480 }, { x: 3630, y: 420 }, { x: 3880, y: 360 },
                    { x: 4130, y: 470 }, { x: 4380, y: 410 },
                ],
                obstacles: [
                    { x: 280, y: 320, startX: 280 },
                    { x: 670, y: 300, startX: 670 },
                    { x: 1030, y: 280, startX: 1030 },
                    { x: 1460, y: 290, startX: 1460 },
                    { x: 1880, y: 270, startX: 1880 },
                    { x: 2180, y: 260, startX: 2180 },
                    { x: 2580, y: 280, startX: 2580 },
                    { x: 2980, y: 270, startX: 2980 },
                    { x: 3230, y: 260, startX: 3230 },
                    { x: 3480, y: 280, startX: 3480 },
                    { x: 3730, y: 270, startX: 3730 },
                    { x: 4230, y: 260, startX: 4230 },
                ],
            },
        };
        
        // Default to level 1
        let currentLevel = 1;

        const COLORS = ['#73A03F', '#AB3D8B', '#0595AE', '#EB8225'];
        const NAMES = ['Verde', 'Morado', 'Turquesa', 'Naranja'];

        const state = {
            players: {},
            games: {},
            started: false,
            starting: false,
            startTime: null,
            admin: null,
            resultsDisplayed: false,
            levelProgress: {
                currentLevel: 1,           // Currently selected level (1-5)
                unlockedLevels: [1],       // Array of unlocked level numbers
                completedLevels: []        // Array of completed level numbers
            }
        };

        let audioCtx;
        const initAudio = () => { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); };
        
        function sound(type) {
            initAudio();
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.connect(g);
            g.connect(audioCtx.destination);
            
            const t = audioCtx.currentTime;
            switch(type) {
                case 'jump':
                    o.frequency.setValueAtTime(400, t);
                    o.frequency.exponentialRampToValueAtTime(800, t + 0.1);
                    g.gain.setValueAtTime(0.1, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    o.start(t); o.stop(t + 0.1);
                    break;
                case 'coin':
                    [1000, 1250, 1500].forEach((f, i) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain); gain.connect(audioCtx.destination);
                        osc.frequency.value = f;
                        gain.gain.setValueAtTime(0.08, t + i * 0.05);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.05 + 0.1);
                        osc.start(t + i * 0.05); osc.stop(t + i * 0.05 + 0.1);
                    });
                    break;
                case 'hit':
                    o.type = 'sawtooth';
                    o.frequency.setValueAtTime(200, t);
                    o.frequency.exponentialRampToValueAtTime(80, t + 0.15);
                    g.gain.setValueAtTime(0.12, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                    o.start(t); o.stop(t + 0.15);
                    break;
                case 'win':
                    [523, 659, 784, 1047].forEach((f, i) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain); gain.connect(audioCtx.destination);
                        osc.frequency.value = f;
                        gain.gain.setValueAtTime(0.1, t + i * 0.12);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.12 + 0.25);
                        osc.start(t + i * 0.12); osc.stop(t + i * 0.12 + 0.25);
                    });
                    break;
                case 'count':
                    o.frequency.value = 500;
                    g.gain.setValueAtTime(0.1, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
                    o.start(t); o.stop(t + 0.12);
                    break;
                case 'go':
                    [600, 900, 1200].forEach((f, i) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain); gain.connect(audioCtx.destination);
                        osc.frequency.value = f;
                        gain.gain.setValueAtTime(0.12, t + i * 0.04);
                        gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.04 + 0.15);
                        osc.start(t + i * 0.04); osc.stop(t + i * 0.04 + 0.15);
                    });
                    break;
            }
        }

        function confetti() {
            const c = document.getElementById('confettiContainer');
            c.innerHTML = '';
            const colors = ['#0595AE', '#AB3D8B', '#EB8225', '#73A03F', '#FFD700'];
            for (let i = 0; i < 150; i++) {
                const el = document.createElement('div');
                el.className = 'confetti';
                el.style.cssText = `left:${Math.random()*100}%;top:-20px;width:${8+Math.random()*8}px;height:${8+Math.random()*8}px;background:${colors[Math.floor(Math.random()*colors.length)]};border-radius:${Math.random()>0.5?'50%':'2px'};animation-delay:${Math.random()*2}s;animation-duration:${2+Math.random()*2}s;`;
                c.appendChild(el);
            }
            setTimeout(() => c.innerHTML = '', 5000);
        }

        async function countdown() {
            const overlay = document.getElementById('countdownOverlay');
            const num = document.getElementById('countdownNumber');
            overlay.classList.remove('hidden');
            
            for (const [val, color] of [['3', '#EB8225'], ['2', '#AB3D8B'], ['1', '#0595AE'], ['GO!', '#73A03F']]) {
                num.textContent = val;
                num.style.color = color;
                num.style.animation = 'none';
                num.offsetHeight;
                num.style.animation = 'countPop 0.6s ease-out';
                sound(val === 'GO!' ? 'go' : 'count');
                await new Promise(r => setTimeout(r, 750));
            }
            
            overlay.classList.add('hidden');
        }

        airconsole.onReady = () => {
            console.log("Screen ready");
            airconsole.setActivePlayers(4);
            setupLevelSelector();
            setupResultsButtons();
        };
        
        function setupResultsButtons() {
            // These buttons are only visible to admin, so they trigger directly
            document.getElementById('nextLevelBtn').addEventListener('click', () => {
                goToNextLevel();
            });
            
            document.getElementById('levelSelectBtn').addEventListener('click', () => {
                returnToLevelSelect();
            });
        }
        airconsole.onConnect = (id) => {
            console.log("ðŸ”Œ Device connected:", id);
            console.log("ðŸ“Š DEBUG: Getting active player device IDs...");
            
            // Get list of active player devices
            const activeDeviceIds = airconsole.getActivePlayerDeviceIds();
            console.log("ðŸ“Š DEBUG: Active device IDs:", activeDeviceIds);
            
            // Check if this device is an active player
            const playerNumber = airconsole.convertDeviceIdToPlayerNumber(id);
            console.log(`ðŸ“Š DEBUG: Device ${id} converted to player number:`, playerNumber);
            
            // Count current connected players (excluding disconnected ones)
            const connectedPlayersCount = Object.keys(state.players).filter(
                slot => !state.players[slot].disconnected
            ).length;
            console.log(`ðŸ“Š DEBUG: Current connected players: ${connectedPlayersCount}/4`);
            
            if (playerNumber !== undefined && playerNumber >= 0 && playerNumber < 4) {
                const playerSlot = playerNumber + 1;
                console.log(`âœ… Device ${id} is active player ${playerSlot} (player number: ${playerNumber})`);
                
                // Check if this player was previously connected but disconnected
                if (state.players[playerSlot]) {
                    const existingPlayer = state.players[playerSlot];
                    
                    // Player is reconnecting
                    if (existingPlayer.disconnected) {
                        console.log(`ðŸ”„ Player ${playerSlot} (${existingPlayer.name}) is reconnecting!`);
                        
                        // Reactivate the player
                        existingPlayer.disconnected = false;
                        existingPlayer.deviceId = id; // Update device ID in case it changed
                        
                        // Notify the controller of their restored state
                        airconsole.message(id, {
                            action: 'reconnected',
                            playerNum: playerSlot,
                            color: existingPlayer.color,
                            colorName: existingPlayer.name,
                            isAdmin: existingPlayer.isAdmin
                        });
                        
                        console.log(`âœ¨ Player ${playerSlot} reactivated successfully`);
                        updateSlots();
                        airconsole.broadcast({ type: 'gameState', players: state.players });
                    } else {
                        console.log(`â„¹ï¸ Player ${playerSlot} already connected (deviceId: ${existingPlayer.deviceId})`);
                    }
                } else {
                    // New player - auto-assign if there's space
                    if (connectedPlayersCount < 4) {
                        console.log(`ðŸŽ® Auto-assigning player ${playerSlot} to device ${id}...`);
                        
                        const isAdmin = !state.admin;
                        if (isAdmin) {
                            state.admin = playerSlot;
                            console.log(`ðŸ‘‘ Player ${playerSlot} assigned as admin`);
                        }
                        
                        state.players[playerSlot] = {
                            deviceId: id,
                            playerNumber: playerNumber,
                            name: NAMES[playerNumber],
                            color: COLORS[playerNumber],
                            isAdmin,
                            disconnected: false
                        };
                        
                        console.log(`ðŸ“Š DEBUG: Player ${playerSlot} data:`, state.players[playerSlot]);
                        
                        // Send joined confirmation to controller
                        airconsole.message(id, {
                            action: 'joined',
                            playerNum: playerSlot,
                            color: COLORS[playerNumber],
                            colorName: NAMES[playerNumber],
                            isAdmin
                        });
                        
                        console.log(`âœ… Player ${playerSlot} auto-assigned and joined successfully!`);
                        updateSlots();
                        airconsole.broadcast({ type: 'gameState', players: state.players });
                    } else {
                        console.log(`âš ï¸ Cannot auto-assign player ${playerSlot}: Game is full (4/4 players)`);
                        
                        // Send game full error to controller
                        airconsole.message(id, {
                            action: 'gameFull'
                        });
                    }
                }
            } else {
                console.log(`âš ï¸ Device ${id} is not an active player (playerNumber: ${playerNumber})`);
                console.log("ðŸ’¡ Device needs to be added as active player via AirConsole dashboard");
            }
        };
        
        function setupLevelSelector() {
            updateLevelButtons();
            
            const levelBtns = document.querySelectorAll('.level-btn');
            levelBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const level = parseInt(btn.dataset.level);
                    // Only allow selecting unlocked levels
                    if (state.levelProgress.unlockedLevels.includes(level)) {
                        selectLevel(level);
                    }
                });
            });
        }
        
        function updateLevelButtons() {
            document.querySelectorAll('.level-btn').forEach(btn => {
                const btnLevel = parseInt(btn.dataset.level);
                const isUnlocked = state.levelProgress.unlockedLevels.includes(btnLevel);
                const isSelected = btnLevel === state.levelProgress.currentLevel;
                const isCompleted = state.levelProgress.completedLevels.includes(btnLevel);
                
                if (isSelected) {
                    btn.className = 'level-btn bg-steam-verde text-white font-bold py-2 px-4 rounded-xl border-2 border-steam-verde';
                    btn.disabled = false;
                } else if (isCompleted) {
                    btn.className = 'level-btn bg-steam-turquesa text-white font-bold py-2 px-4 rounded-xl border-2 border-steam-turquesa';
                    btn.disabled = false;
                } else if (isUnlocked) {
                    btn.className = 'level-btn bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-xl border-2 border-gray-300';
                    btn.disabled = false;
                } else {
                    btn.className = 'level-btn bg-gray-100 text-gray-400 font-bold py-2 px-4 rounded-xl border-2 border-gray-200 opacity-50 cursor-not-allowed';
                    btn.disabled = true;
                }
            });
        }
        
        function selectLevel(level) {
            state.levelProgress.currentLevel = level;
            updateLevelButtons();
            
            // Update level name
            document.getElementById('levelName').textContent = LEVELS[level].name;
            
            // Broadcast to controllers
            airconsole.broadcast({ type: 'levelChanged', level, name: LEVELS[level].name });
        }
        
        airconsole.onDisconnect = (id) => {
            console.log("ðŸ”Œ Device disconnected:", id);
            
            // Use player number instead of searching by deviceId
            const playerNumber = airconsole.convertDeviceIdToPlayerNumber(id);
            
            if (playerNumber !== undefined && playerNumber >= 0 && playerNumber < 4) {
                const playerSlot = playerNumber + 1;
                
                if (state.players[playerSlot]) {
                    const player = state.players[playerSlot];
                    console.log(`âš ï¸ Player ${playerSlot} (${player.name}) disconnected - marking as disconnected`);
                    
                    player.disconnected = true;
                    updateSlots();
                    
                    // Broadcast the disconnection to other players
                    airconsole.broadcast({ 
                        type: 'playerDisconnected', 
                        playerNum: playerSlot,
                        playerName: player.name
                    });
                    
                    console.log(`ðŸ“Š Active players: ${Object.values(state.players).filter(p => !p.disconnected).length}/${Object.keys(state.players).length}`);
                } else {
                    console.log(`â„¹ï¸ Disconnected device ${id} (player ${playerSlot}) was not in active players`);
                }
            } else {
                console.log(`â„¹ï¸ Disconnected device ${id} was not an active player (playerNumber: ${playerNumber})`);
            }
        };

        airconsole.onMessage = (id, data) => {
            if (data.action === 'join') {
                // Simplified join handler - only needed as fallback since onConnect handles auto-join
                const playerNumber = airconsole.convertDeviceIdToPlayerNumber(id);
                
                if (playerNumber !== undefined && playerNumber >= 0 && playerNumber < 4) {
                    const playerSlot = playerNumber + 1;
                    
                    // Check if player already exists
                    if (state.players[playerSlot]) {
                        // Player already joined, just send confirmation
                        const p = state.players[playerSlot];
                        airconsole.message(id, {
                            action: 'joined',
                            playerNum: playerSlot,
                            color: p.color,
                            colorName: p.name,
                            isAdmin: p.isAdmin
                        });
                    }
                }
            } else if (data.action === 'selectColor') {
                for (let n in state.players) {
                    if (state.players[n].deviceId === id) {
                        state.players[n].color = data.color;
                        state.players[n].name = data.colorName;
                        updateSlots();
                        airconsole.message(id, { action: 'colorUpdated', color: data.color, colorName: data.colorName });
                        break;
                    }
                }
            } else if (data.action === 'startGame') {
                const playerNumber = airconsole.convertDeviceIdToPlayerNumber(id);
                const playerSlot = playerNumber !== undefined ? playerNumber + 1 : null;
                if (playerSlot === state.admin) {
                    startGame();
                }
            } else if (data.action === 'playAgain') {
                const playerNumber = airconsole.convertDeviceIdToPlayerNumber(id);
                const playerSlot = playerNumber !== undefined ? playerNumber + 1 : null;
                if (playerSlot === state.admin) {
                    restart();
                }
            } else if (data.action === 'nextLevel') {
                const playerNumber = airconsole.convertDeviceIdToPlayerNumber(id);
                const playerSlot = playerNumber !== undefined ? playerNumber + 1 : null;
                if (playerSlot === state.admin) {
                    goToNextLevel();
                }
            } else if (data.action === 'goToLevelSelect') {
                const playerNumber = airconsole.convertDeviceIdToPlayerNumber(id);
                const playerSlot = playerNumber !== undefined ? playerNumber + 1 : null;
                if (playerSlot === state.admin) {
                    returnToLevelSelect();
                }
            } else {
                const playerNumber = airconsole.convertDeviceIdToPlayerNumber(id);
                
                if (playerNumber !== undefined && playerNumber >= 0) {
                    const n = playerNumber + 1;
                    
                    if (state.games[n] && state.started) {
                        const g = state.games[n];
                        if (data.action === 'move') {
                            g.keys.left = data.direction === 'left';
                            g.keys.right = data.direction === 'right';
                        } else if (data.action === 'stop') {
                            g.keys.left = g.keys.right = false;
                        } else if (data.action === 'jump') {
                            g.keys.jump = data.pressed;
                        }
                    }
                }
            }
        };

        function updateSlots() {
            const count = Object.keys(state.players).length;
            for (let i = 1; i <= 4; i++) {
                const slot = document.getElementById(`playerSlot${i}`);
                const p = state.players[i];
                
                slot.className = 'player-card';
                
                if (p) {
                    slot.classList.add(p.isAdmin ? 'admin' : 'ready');
                    slot.innerHTML = `
                        <div class="text-lg sm:text-xl font-bold flex items-center justify-center gap-2" style="color:${p.color}">
                            ${p.isAdmin ? '<iconify-icon icon="mdi:crown" class="text-steam-naranja text-2xl"></iconify-icon>' : '<iconify-icon icon="mdi:account-check" class="text-xl"></iconify-icon>'}
                            ${p.name}
                        </div>
                        <div class="flex justify-center my-3 float">
                            <div class="player-avatar" style="background:${p.color}"></div>
                        </div>
                        <div class="text-sm font-bold flex items-center justify-center gap-1 ${p.disconnected ? 'text-steam-morado' : 'text-steam-verde'}">
                            ${p.disconnected 
                                ? '<iconify-icon icon="mdi:wifi-off"></iconify-icon> Desconectado' 
                                : '<iconify-icon icon="mdi:check-circle"></iconify-icon> Listo!'}
                        </div>
                    `;
                } else {
                    slot.innerHTML = `
                        <div class="text-lg sm:text-xl font-bold text-gray-400 flex items-center justify-center gap-2">
                            <iconify-icon icon="mdi:controller" class="text-xl"></iconify-icon>
                            Jugador ${i}
                        </div>
                        <div class="flex justify-center my-3 float">
                            <div class="player-avatar bg-gray-200"></div>
                        </div>
                        <div class="text-sm text-gray-400 flex items-center justify-center gap-1">
                            <iconify-icon icon="mdi:timer-sand" class="animate-pulse"></iconify-icon>
                            Esperando...
                        </div>
                    `;
                }
            }
            
            document.getElementById('adminHint').classList.toggle('hidden', count === 0);
            document.getElementById('levelSelector').classList.toggle('hidden', count === 0);
        }

        async function startGame() {
            // Prevent multiple simultaneous start calls
            if (state.started || state.starting) return;
            state.starting = true;
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            
            const players = Object.values(state.players).filter(p => !p.disconnected);
            setupScreens(players.length);
            
            let i = 0;
            for (let n in state.players) {
                if (!state.players[n].disconnected) {
                    state.games[n] = new Game(n, state.players[n].color, state.players[n].name);
                    state.games[n].init();
                    i++;
                }
            }
            
            await countdown();
            
            state.started = true;
            state.starting = false;
            state.startTime = Date.now();
            airconsole.broadcast({ type: 'gameStart' });
        }

        function setupScreens(count) {
            const container = document.getElementById('gameContainer');
            container.innerHTML = '';
            
            let i = 0;
            for (let n in state.players) {
                if (state.players[n].disconnected) continue;
                const p = state.players[n];
                
                const div = document.createElement('div');
                div.id = `screen${n}`;
                div.className = 'absolute overflow-hidden';
                
                // Layout based on player count
                if (count === 1) {
                    div.style.cssText = 'inset:0;';
                } else if (count === 2) {
                    div.style.cssText = `left:0;right:0;height:calc(50% - 2px);${i === 0 ? 'top:0' : 'bottom:0'};`;
                } else if (count === 3) {
                    if (i === 0) div.style.cssText = 'top:0;left:0;right:0;height:calc(50% - 2px);';
                    else div.style.cssText = `bottom:0;width:calc(50% - 2px);height:calc(50% - 2px);${i === 1 ? 'left:0' : 'right:0'};`;
                } else {
                    const pos = [['top:0;left:0'], ['top:0;right:0'], ['bottom:0;left:0'], ['bottom:0;right:0']][i];
                    div.style.cssText = `${pos};width:calc(50% - 2px);height:calc(50% - 2px);`;
                }
                
                const levelData = LEVELS[state.levelProgress.currentLevel];
                div.innerHTML = `
                    <canvas id="canvas${n}" class="absolute inset-0 w-full h-full"></canvas>
                    <div class="absolute top-3 left-3 sm:top-4 sm:left-4 bg-black/70 rounded-xl py-2 px-4 flex items-center gap-2 text-white font-bold text-sm sm:text-lg z-10" style="border-left:4px solid ${p.color}">
                        <iconify-icon icon="mdi:cash-multiple" class="text-steam-naranja text-lg"></iconify-icon>
                        <span id="coins${n}">0</span>/<span>${levelData.coins.length}</span>
                    </div>
                    <div class="absolute top-3 right-3 sm:top-4 sm:right-4 bg-black/70 rounded-xl py-2 px-3 flex items-center gap-2 font-bold z-10" style="border-left:4px solid ${p.color}">
                        <div class="w-6 h-6 sm:w-8 sm:h-8 rounded-lg relative" style="background:${p.color}">
                            <span class="absolute top-1 left-1 w-1.5 h-1.5 sm:w-2 sm:h-2 bg-white rounded-full"></span>
                            <span class="absolute top-1 right-1 w-1.5 h-1.5 sm:w-2 sm:h-2 bg-white rounded-full"></span>
                        </div>
                        <span class="text-white text-sm sm:text-base">${p.name}</span>
                    </div>
                    <div class="absolute bottom-3 left-3 right-3 sm:bottom-4 sm:left-4 sm:right-4 flex items-center gap-2 z-10">
                        <div class="flex-1 h-2 bg-black/30 rounded-full overflow-hidden">
                            <div id="progress${n}" class="h-full rounded-full transition-all" style="width:0%;background:${p.color}"></div>
                        </div>
                        <div class="bg-black/70 rounded-lg px-2 py-1 text-white text-xs font-bold">
                            Nivel ${state.levelProgress.currentLevel}
                        </div>
                    </div>
                `;
                
                if (count > 1) {
                    div.style.border = `3px solid ${p.color}`;
                }
                
                container.appendChild(div);
                i++;
            }
        }

        function restart() {
            // Prevent multiple restart calls
            if (!state.resultsDisplayed) return;
            
            document.getElementById('resultsScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('gameContainer').style.display = 'none';
            
            // Stop all running game loops before resetting
            for (let n in state.games) {
                if (state.games[n] && state.games[n].stop) {
                    state.games[n].stop();
                }
            }
            
            state.started = false;
            state.starting = false;
            state.games = {};
            state.resultsDisplayed = false;
            
            for (let n in state.players) {
                if (state.players[n].disconnected) delete state.players[n];
            }
            
            updateSlots();
            updateLevelButtons();
            airconsole.broadcast({ type: 'gameRestart' });
        }
        
        function goToNextLevel() {
            if (!state.resultsDisplayed) return;
            
            const nextLevel = state.levelProgress.currentLevel + 1;
            if (nextLevel <= 5) {
                selectLevel(nextLevel);
                restart();
            }
        }
        
        function returnToLevelSelect() {
            restart();
        }

        function showResults() {
            const results = [];
            
            for (let n in state.games) {
                const g = state.games[n];
                const p = state.players[n];
                if (g.finishTime && !p.disconnected) {
                    const timeBonus = Math.max(0, 1000 - (g.finishTime - state.startTime) / 100);
                    const coinBonus = g.coins * 100;
                    results.push({
                        num: n,
                        name: p.name,
                        color: p.color,
                        coins: g.coins,
                        time: ((g.finishTime - state.startTime) / 1000).toFixed(1),
                        score: Math.round(timeBonus + coinBonus)
                    });
                }
            }
            
            results.sort((a, b) => b.score - a.score);
            
            // Check if level was completed (at least one player finished)
            const levelCompleted = results.length > 0;
            const currentLevel = state.levelProgress.currentLevel;
            
            if (levelCompleted) {
                // Mark level as completed
                if (!state.levelProgress.completedLevels.includes(currentLevel)) {
                    state.levelProgress.completedLevels.push(currentLevel);
                }
                
                // Unlock next level if exists
                const nextLevel = currentLevel + 1;
                if (nextLevel <= 5 && !state.levelProgress.unlockedLevels.includes(nextLevel)) {
                    state.levelProgress.unlockedLevels.push(nextLevel);
                }
            }
            
            const winnerDiv = document.getElementById('winnerSection');
            if (results.length) {
                const w = results[0];
                winnerDiv.innerHTML = `
                    <iconify-icon icon="mdi:trophy" class="text-6xl text-steam-naranja mb-4"></iconify-icon>
                    <div class="player-avatar mx-auto mb-4" style="background:${w.color};width:100px;height:100px;border-radius:20px;box-shadow:0 0 30px ${w.color}50"></div>
                    <div class="text-2xl font-black" style="color:${w.color}">${w.name}</div>
                    <div class="text-xl text-steam-verde font-bold mt-2 flex items-center justify-center gap-2">
                        <iconify-icon icon="mdi:star"></iconify-icon>
                        ${w.score} pts
                    </div>
                `;
                sound('win');
                confetti();
            }
            
            const tbody = document.getElementById('resultsBody');
            tbody.innerHTML = '';
            const medals = ['mdi:medal-outline', 'mdi:medal-outline', 'mdi:medal-outline'];
            const medalColors = ['#FFD700', '#C0C0C0', '#CD7F32'];
            
            results.forEach((r, i) => {
                const row = document.createElement('tr');
                row.className = i === 0 ? 'bg-amber-50' : i % 2 ? 'bg-gray-50' : '';
                row.innerHTML = `
                    <td class="py-3 px-2 text-xl">
                        ${i < 3 
                            ? `<iconify-icon icon="${medals[i]}" style="color:${medalColors[i]}" class="text-2xl"></iconify-icon>` 
                            : `#${i+1}`}
                    </td>
                    <td class="py-3 px-2">
                        <div class="flex items-center gap-2">
                            <div class="w-6 h-6 rounded-md relative" style="background:${r.color}">
                                <span class="absolute top-1 left-1 w-1.5 h-1.5 bg-white rounded-full"></span>
                                <span class="absolute top-1 right-1 w-1.5 h-1.5 bg-white rounded-full"></span>
                            </div>
                            <span class="font-bold">${r.name}</span>
                        </div>
                    </td>
                    <td class="py-3 px-2 text-center text-steam-naranja font-bold">${r.coins}</td>
                    <td class="py-3 px-2 text-center">${r.time}s</td>
                    <td class="py-3 px-2 text-right font-black text-steam-verde">${r.score}</td>
                `;
                tbody.appendChild(row);
            });
            
            // Show appropriate buttons
            const hasNextLevel = currentLevel < 5;
            const nextLevelBtn = document.getElementById('nextLevelBtn');
            const levelSelectBtn = document.getElementById('levelSelectBtn');
            const waitingAdmin = document.getElementById('waitingAdmin');
            
            if (levelCompleted && hasNextLevel) {
                nextLevelBtn.classList.remove('hidden');
            } else {
                nextLevelBtn.classList.add('hidden');
            }
            
            levelSelectBtn.classList.remove('hidden');
            waitingAdmin.classList.add('hidden');
            
            document.getElementById('resultsScreen').style.display = 'flex';
            airconsole.broadcast({ type: 'gameResults', results, winner: results[0], levelCompleted, hasNextLevel });
        }

        class Game {
            constructor(num, color, name) {
                this.num = num;
                this.color = color;
                this.name = name;
                this.canvas = null;
                this.ctx = null;
                this.keys = { left: false, right: false, jump: false };
                this.finishTime = null;
                this.resultsShown = false;
                this.running = false;
                this.animationFrameId = null;
                
                this.player = { x: 80, y: 300, vx: 0, vy: 0, w: 44, h: 44, facing: 1, stunned: 0 };
                this.coins = 0;
                this.won = false;
                this.grounded = false;
                this.camX = 0;
                this.particles = [];
                this.trail = [];
                
                // Clone level data from selected level
                const levelData = LEVELS[state.levelProgress.currentLevel];
                this.floors = levelData.floorSegments.map(f => ({...f}));
                this.platforms = levelData.platforms.map(p => ({...p, h: 16}));
                this.coinList = levelData.coins.map(c => ({...c, got: false, bob: Math.random() * 6.28}));
                this.obstacles = levelData.obstacles.map(o => ({...o, w: 38, h: 38, dir: 1, spd: 2 + Math.random(), range: 100 + Math.random() * 50}));
                this.finishX = levelData.length - 200;
            }

            init() {
                this.canvas = document.getElementById(`canvas${this.num}`);
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                
                const container = document.getElementById(`screen${this.num}`);
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                const ratio = this.canvas.height / 700;
                this.floorY = this.canvas.height - 70;
                
                this.floors.forEach(f => f.y = this.floorY);
                this.platforms.forEach(p => p.y *= ratio);
                this.coinList.forEach(c => c.y *= ratio);
                this.obstacles.forEach(o => o.y *= ratio);
                this.player.y = 300 * ratio;
                
                this.coinsEl = document.getElementById(`coins${this.num}`);
                this.progressEl = document.getElementById(`progress${this.num}`);
                
                this.running = true;
                this.loop();
            }

            update() {
                if (this.won || !state.started) return;
                
                const p = this.player;
                const prevY = p.y;
                
                // Input - improved movement physics
                if (!p.stunned) {
                    // Apply acceleration for smoother movement
                    const targetVx = this.keys.left ? -PHYSICS_CONFIG.moveSpeed : (this.keys.right ? PHYSICS_CONFIG.moveSpeed : 0);
                    const acceleration = this.grounded ? PHYSICS_CONFIG.groundAcceleration : PHYSICS_CONFIG.airAcceleration;
                    
                    if (targetVx !== 0) {
                        p.vx += (targetVx - p.vx) * acceleration;
                        p.facing = targetVx > 0 ? 1 : -1;
                    } else if (this.grounded) {
                        // Apply friction when not moving
                        p.vx *= PHYSICS_CONFIG.friction;
                        if (Math.abs(p.vx) < 0.1) p.vx = 0;
                    }
                } else {
                    // Still apply some air resistance when stunned
                    p.vx *= PHYSICS_CONFIG.airResistance;
                }
                
                if (p.stunned > 0) p.stunned--;
                
                // Physics - improved gravity and terminal velocity
                p.vy += PHYSICS_CONFIG.gravity;
                
                // Terminal velocity
                if (p.vy > PHYSICS_CONFIG.maxFallSpeed) p.vy = PHYSICS_CONFIG.maxFallSpeed;
                
                // Jump - improved jump feel with variable height
                if (this.keys.jump && this.grounded && !p.stunned) {
                    p.vy = PHYSICS_CONFIG.jumpPower;
                    sound('jump');
                    this.keys.jump = false;
                    this.burst(p.x + p.w/2, p.y + p.h, '#8BC34A', 5);
                }
                
                // Cut jump short if button released (variable jump height)
                if (!this.keys.jump && p.vy < PHYSICS_CONFIG.jumpCutThreshold) {
                    p.vy *= PHYSICS_CONFIG.jumpCutMultiplier;
                }
                
                // Apply horizontal movement with collision check
                const newX = p.x + p.vx;
                p.x = newX;
                
                // Trail - optimized for performance
                if (Math.abs(p.vx) > 1 || Math.abs(p.vy) > 3) {
                    this.trail.push({ x: p.x, y: p.y, a: 0.4 });
                    if (this.trail.length > 4) this.trail.shift(); // Reduced from 6 to 4
                }
                // Optimize trail updates
                for (let i = this.trail.length - 1; i >= 0; i--) {
                    this.trail[i].a *= 0.85;
                    if (this.trail[i].a <= 0.05) {
                        this.trail.splice(i, 1);
                    }
                }
                
                // Apply vertical movement with improved collision detection
                const newY = p.y + p.vy;
                p.y = newY;
                
                // Collisions - improved with better precision
                this.grounded = false;
                let landedThisFrame = false;
                
                // Floors - improved collision with better threshold
                this.floors.forEach(f => {
                    if (p.x + p.w > f.x + 2 && p.x < f.x + f.width - 2) {
                        // Check if player is landing on floor (coming from above)
                        if (p.vy >= 0 && prevY + p.h <= f.y + 5 && p.y + p.h >= f.y) {
                            p.y = f.y - p.h;
                            p.vy = 0;
                            this.grounded = true;
                            landedThisFrame = true;
                        }
                    }
                });
                
                // Platforms - improved collision detection
                this.platforms.forEach(pl => {
                    if (p.x + p.w > pl.x + 2 && p.x < pl.x + pl.width - 2) {
                        // Only collide when coming from above
                        if (p.vy >= 0 && prevY + p.h <= pl.y + 5 && p.y + p.h >= pl.y && p.y < pl.y + pl.h) {
                            p.y = pl.y - p.h;
                            p.vy = 0;
                            this.grounded = true;
                            landedThisFrame = true;
                        }
                    }
                });
                
                // Fall death
                if (p.y > this.canvas.height + 50) {
                    this.burst(p.x + p.w/2, this.canvas.height - 50, '#AB3D8B', 12);
                    p.x = 80;
                    p.y = 300 * (this.canvas.height / 700);
                    p.vx = p.vy = 0;
                    sound('hit');
                }
                
                // Obstacles - optimized with culling
                this.obstacles.forEach(o => {
                    o.x += o.dir * o.spd;
                    if (Math.abs(o.x - o.startX) > o.range) o.dir *= -1;
                    
                    // Only check collision if obstacle is near player (culling)
                    const cullDistance = 200;
                    if (Math.abs(o.x - p.x) > cullDistance) return;
                    
                    // Better AABB collision with small margin to prevent tunneling
                    const margin = 2;
                    if (!p.stunned && 
                        p.x + p.w - margin > o.x && 
                        p.x + margin < o.x + o.w && 
                        p.y + p.h - margin > o.y && 
                        p.y + margin < o.y + o.h) {
                        p.stunned = 45;
                        sound('hit');
                        this.burst(p.x + p.w/2, p.y + p.h/2, '#AB3D8B', 8); // Reduced particles
                        // Knockback effect
                        p.vy = -8;
                        p.vx = o.dir * -4;
                    }
                });
                
                // Bounds
                p.x = Math.max(0, p.x);
                
                // Camera
                this.camX = Math.max(0, Math.min(p.x - this.canvas.width / 2, this.finishX - this.canvas.width + 150));
                
                // Progress
                if (this.progressEl) this.progressEl.style.width = Math.min(100, p.x / this.finishX * 100) + '%';
                
                // Coins - optimized with culling and distance check
                this.coinList.forEach(c => {
                    if (c.got) return;
                    
                    // Quick cull check before expensive distance calculation
                    const cullDistance = 100;
                    if (Math.abs(c.x - p.x) > cullDistance) return;
                    
                    const dx = (p.x + p.w/2) - c.x;
                    const dy = (p.y + p.h/2) - c.y;
                    
                    // Use squared distance to avoid sqrt
                    const distSq = dx * dx + dy * dy;
                    if (distSq < 900) { // 30 * 30 = 900
                        c.got = true;
                        this.coins++;
                        if (this.coinsEl) this.coinsEl.textContent = this.coins;
                        this.burst(c.x, c.y, '#EB8225', 8); // Reduced particles
                        sound('coin');
                    }
                });
                
                // Finish
                if (p.x > this.finishX && !this.won) {
                    this.won = true;
                    this.finishTime = Date.now();
                    this.burst(p.x + p.w/2, p.y, '#73A03F', 20);
                    
                    // Use a flag to prevent multiple calls
                    if (!this.resultsShown) {
                        this.resultsShown = true;
                        const allDone = Object.values(state.games).every(g => g.won || state.players[g.num].disconnected);
                        if (allDone) {
                            // Check one more time before showing results
                            if (!state.resultsDisplayed) {
                                state.resultsDisplayed = true;
                                setTimeout(showResults, 1200);
                            }
                        }
                    }
                }
                
                // Particles - optimized loop
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const pt = this.particles[i];
                    pt.x += pt.vx;
                    pt.y += pt.vy;
                    pt.vy += 0.15;
                    pt.life--;
                    if (pt.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            draw() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // Sky - clean solid colors
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, w, h * 0.4);
                ctx.fillStyle = '#98D8C8';
                ctx.fillRect(0, h * 0.4, w, h * 0.3);
                ctx.fillStyle = '#2D5A4A';
                ctx.fillRect(0, h * 0.7, w, h * 0.3);
                
                ctx.save();
                ctx.translate(-this.camX, 0);
                
                // Simple clouds - only draw visible ones (culling)
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                const clouds = [[100, 60], [400, 90], [800, 50], [1200, 80], [1700, 65], [2200, 75], [2700, 55]];
                clouds.forEach(([x, y]) => {
                    // Cull clouds outside view
                    if (x < this.camX - 100 || x > this.camX + w + 100) return;
                    ctx.beginPath();
                    ctx.arc(x, y, 30, 0, Math.PI * 2);
                    ctx.arc(x + 25, y - 5, 22, 0, Math.PI * 2);
                    ctx.arc(x + 50, y, 28, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Ground - with culling
                this.floors.forEach(f => {
                    // Only draw visible floor segments
                    if (f.x + f.width < this.camX || f.x > this.camX + w) return;
                    
                    // Dirt
                    ctx.fillStyle = '#5D4037';
                    ctx.fillRect(f.x, f.y, f.width, 70);
                    // Grass
                    ctx.fillStyle = '#8BC34A';
                    ctx.fillRect(f.x, f.y, f.width, 12);
                    // Grass detail
                    ctx.fillStyle = '#9CCC65';
                    for (let gx = f.x + 10; gx < f.x + f.width - 10; gx += 25) {
                        ctx.fillRect(gx, f.y - 4, 3, 8);
                    }
                });
                
                // Platforms - with culling
                this.platforms.forEach(pl => {
                    // Only draw visible platforms
                    if (pl.x + pl.width < this.camX || pl.x > this.camX + w) return;
                    
                    ctx.fillStyle = '#546E7A';
                    ctx.fillRect(pl.x, pl.y, pl.width, pl.h);
                    ctx.fillStyle = '#78909C';
                    ctx.fillRect(pl.x, pl.y, pl.width, 4);
                });
                
                // Obstacles - with culling
                this.obstacles.forEach(o => {
                    // Only draw visible obstacles
                    if (o.x + o.w < this.camX || o.x > this.camX + w) return;
                    
                    ctx.fillStyle = '#AB3D8B';
                    ctx.beginPath();
                    ctx.roundRect(o.x, o.y, o.w, o.h, 8);
                    ctx.fill();
                    // Eyes
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(o.x + o.w * 0.3, o.y + o.h * 0.4, 6, 0, Math.PI * 2);
                    ctx.arc(o.x + o.w * 0.7, o.y + o.h * 0.4, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(o.x + o.w * 0.3 + o.dir * 2, o.y + o.h * 0.4, 3, 0, Math.PI * 2);
                    ctx.arc(o.x + o.w * 0.7 + o.dir * 2, o.y + o.h * 0.4, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Coins - with culling
                const t = performance.now();
                this.coinList.forEach(c => {
                    if (c.got) return;
                    
                    // Only draw visible coins
                    if (c.x < this.camX - 50 || c.x > this.camX + w + 50) return;
                    
                    const bobY = Math.sin(t / 200 + c.bob) * 4;
                    ctx.fillStyle = '#EB8225';
                    ctx.beginPath();
                    ctx.arc(c.x, c.y + bobY, 14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(c.x - 4, c.y + bobY - 4, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', c.x, c.y + bobY + 1);
                });
                
                // Finish flag
                const fx = this.finishX;
                ctx.fillStyle = '#455A64';
                ctx.fillRect(fx, this.floorY - 130, 6, 130);
                ctx.fillStyle = '#73A03F';
                ctx.beginPath();
                ctx.moveTo(fx + 6, this.floorY - 130);
                ctx.lineTo(fx + 60, this.floorY - 105);
                ctx.lineTo(fx + 6, this.floorY - 80);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('META', fx + 33, this.floorY - 102);
                
                // Checkered finish
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 2; j++) {
                        ctx.fillStyle = (i + j) % 2 ? '#333' : '#fff';
                        ctx.fillRect(fx - 40 + i * 12, this.floorY - 20 + j * 10, 12, 10);
                    }
                }
                
                // Particles
                this.particles.forEach(pt => {
                    ctx.globalAlpha = pt.life / 30;
                    ctx.fillStyle = pt.color;
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                
                // Trail
                this.trail.forEach(tr => {
                    ctx.globalAlpha = tr.a * 0.5;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.roundRect(tr.x + 5, tr.y + 5, this.player.w - 10, this.player.h - 10, 8);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                
                // Player
                const p = this.player;
                if (p.stunned) ctx.globalAlpha = 0.4 + Math.sin(t / 40) * 0.3;
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(p.x + p.w/2, p.y + p.h + 4, p.w/2 * 0.7, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.roundRect(p.x, p.y, p.w, p.h, 12);
                ctx.fill();
                
                // Highlight
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.roundRect(p.x + 5, p.y + 4, p.w - 10, 12, 6);
                ctx.fill();
                
                // Eyes
                const eyeY = p.y + p.h * 0.38;
                const eyeX1 = p.x + p.w * 0.3;
                const eyeX2 = p.x + p.w * 0.7;
                const lookX = p.facing * 3;
                
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(eyeX1, eyeY, 7, 0, Math.PI * 2);
                ctx.arc(eyeX2, eyeY, 7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.arc(eyeX1 + lookX, eyeY, 3, 0, Math.PI * 2);
                ctx.arc(eyeX2 + lookX, eyeY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
                ctx.restore();
            }

            burst(x, y, color, count) {
                // Limit total particle count for performance
                const maxParticles = 150;
                const actualCount = Math.min(count, maxParticles - this.particles.length);
                
                for (let i = 0; i < actualCount; i++) {
                    this.particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8 - 3,
                        life: 25 + Math.random() * 10,
                        color
                    });
                }
            }

            resize(newWidth, newHeight) {
                const oldWidth = this.canvas.width;
                const oldHeight = this.canvas.height;
                
                // Update canvas dimensions
                this.canvas.width = newWidth;
                this.canvas.height = newHeight;
                
                // Calculate scaling ratios
                const oldRatio = oldHeight / 700;
                const newRatio = newHeight / 700;
                const scaleY = newRatio / oldRatio;
                
                // Update floor Y position
                this.floorY = newHeight - 70;
                
                // Recalculate all vertical positions
                this.floors.forEach(f => f.y = this.floorY);
                
                this.platforms.forEach(p => {
                    p.y *= scaleY;
                });
                
                this.coinList.forEach(c => {
                    c.y *= scaleY;
                });
                
                this.obstacles.forEach(o => {
                    o.y *= scaleY;
                });
                
                // Recalculate player position
                this.player.y *= scaleY;
            }

            loop() {
                // Exit if game is no longer running
                if (!this.running) {
                    return;
                }
                
                // Frame rate limiting for better performance
                const now = performance.now();
                const deltaTime = now - (this.lastFrameTime || now);
                this.lastFrameTime = now;
                
                // Target 60fps (16.67ms per frame)
                const targetFrameTime = 1000 / 60;
                
                // Only update if enough time has passed
                if (deltaTime >= targetFrameTime * 0.9) {
                    this.update();
                    this.draw();
                }
                
                this.animationFrameId = requestAnimationFrame(() => this.loop());
            }
            
            stop() {
                this.running = false;
                if (this.animationFrameId !== null) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            if (state.started) {
                // Debounce resize to prevent excessive recalculations
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    for (let n in state.games) {
                        const g = state.games[n];
                        const container = document.getElementById(`screen${n}`);
                        if (container && g.canvas) {
                            g.resize(container.clientWidth, container.clientHeight);
                        }
                    }
                }, 100);
            }
        });
    </script>
</body>
</html>
